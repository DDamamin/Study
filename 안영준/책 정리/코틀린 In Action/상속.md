#### 상속 

상속 = 기존의 클래스에 기능을 확장하고자 할때 현재의 클래스의 기능을 모두 가지고 자신만의 기능이 추가된 새로운 클래스를 정의 하는 방법이다. 따라서 클래스가  상속할경우 우 상,하의 구조를 가지게된다.

코틀린에서의 모든 클래스는 공통의 상위클래스로 Any클래스를 가진다. 이것이 클래스에 상위 클래스를 선언하지 않을때 가지는 기본 상위 클래스이다.

class abcd // 임시적으로 Any클래스로부터 상속 받고 있다.(Any는 자바에서의 java.lang.Object같아보이지만 자바의 object와 다르게 Any는 equals(), hashCode(), toString()이외의 멤버는 가지지 않는다. 또한 object는 clone(), notify()등 다른 멤버가 더 있다.)

명시적으로 상위 클래스를 지정하기 위해서 클래스 헤더에 콜론과 상위타입을 적는다.

파생 클래스가 기본 생성자를 가진다면, 베이스 클래스는 기본 생성자의 인자를 사용해서 바로 초기화 될 수 있고, 그렇게 되어야한다.

파생 클래스가 기본 생성자를 가지지 않는다면, 각 보조 생성자는 super 키워드를 사용해서 베이스 타입을 초기화 하거나, 초기화 수행하는 다른 생성자에게 위임해야 한다.(서로 다른 보조 생성자들이 베이스 타입의 다른 생성자를 호출할 수 있음에 유의해야 한다.)

open class abcde(var name:String)

class abcd(name:String):Person(name)

val abcd = abcd("A")

println("abcd name = ${abcd.name }")  

abcd의 주생성자를 호출하고, 그 후 부모 클래스에 있는 property인 name을 초기화하기 위하여  abcde의 주생성자 호출 될 것이다. 마치 부새성자 this 로 주생ㅇ성자를 호출하여 property를 초기화하듯이 동작한다.

open의 키워드는 java 클래스의 final을 명시했을 때 상속이 불가능하며 특별히 명시하지 않을 때의 final이 아니다. 코틀린 클래스는 open 을 명시해야 상속이 가능하며, 그렇지 않을경우 java의 final클래스와 같다.

(즉 명시를 하지않으면 final클래스이다.)

 상속가능 -> open , 불가능 ->final