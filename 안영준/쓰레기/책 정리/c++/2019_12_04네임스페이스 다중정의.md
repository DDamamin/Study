#### 네임스페이스 다중정의

네임스페이스::이름 의 형태를 이룸 (네임스페이스가 달라도 나머지(함수이름, 매개변수 구성)가 같은형태로 선언이 되어있으면, 다중정의가 가능하다.)



#### 식별자 검색 순서

**전역 함수인 경우**

1. 1. 1. 현재 블록 범위
      2. 현재 블록 범위를 포함하고 있는 상위 블록 범위 (최대 적용 범위는 함수 몸체까지)
      3. 가장 최근에 선언된 전역 변수나 함수
      4. using 선언된 네임스페이스 혹은 전역 네임스페이스. 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생! 

**클래스 메소드인 경우**

1. 1. 1. 현재 블록 범위
      2. 현재 블록 범위를 포함하고 있는 상위 블록 범위 (최대 적용 범위는 함수 몸체까지)
      3. 클래스의 멤버
      4. 부모 클래스의 멤버
      5. 가장 최근에 선언된 전역 변수나 함수
      6. 호출자 코드가 속한 네임스페이스의 상위 네임스페이스
      7. using 선언된 네임스페이스 혹은 전역 네임스페이스. 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생!

##### 현재 블록 범위

코드가 속한 블록 범위({}구간)

##### 상위 블록 범위

현재블록안에서 찾지 못한다면 상위블록으로 검색범위를 확장함.(하지만 확장 범위는 최대 함수 몸체까지로 제한됨. 만약 벗어나면 네임스페이스,클래스 범위로 확장됨, 제어문, 반복문에서 자주볼수있음)

##### 가장 최근에 선언된 전역 변수

네임스페이스는 선언할 수 있는 대상 모두를 한영역으로 묶어줌

전역 변수는 네임스페이스 보다 선언위치가 더 우선된다.

(전역 변수는 네임스페이스를 생각하지않고 선언 순서를 생각해야됨.)

예를들어

int a = 100;

namespace ab

{

void func(void)

{

cout<<nData<<endl;

}

}

이 코드를 예로들경우 100이 출력되지만, 



namespace ab

{

void func(void)

{

cout<<nData<<endl;

}

}

int a = 100;

이렇게 될경우 에러가 뜬다.  즉 이렇게 선언순서가 중요하다는것을알수있다.

##### using 선언과 전역변수

using namespace 선언을 통해 매번 식별자 앞에 네임스페이스 번거로움 할수있다하였지만,

중복이 될경우 에러가 뜬다, 그럴 경우에는 main함수에 범위 지정식별자를 쓰면된다.