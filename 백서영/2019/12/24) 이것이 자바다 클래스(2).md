#### 필드

객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수와 비슷하나, 필드를 변수라고 부르지 않는다.  필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

#### 생성자

생성자는 new 연산자로 호출되는 특별한 중괄호 블록이다. 객체 생성 시 초기화를 담당하며 메소드를 호출해서 객체를 사용할 준비를 한다. 클래스 이름으로 되어 있고 리턴 타입이 없다.

#### 메소드

객체의 동작에 해당되는 중괄호 블록이다. 메소드를 호출하게 {} 블록에 있는 모든 코드들이 일관적으로 실행된다. 필드를 읽고 수정하는 여갈도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 객체 간의 데이터 전달 수단으로 사용되며 외부로부터 매개값을 받을 수 있고, 실행 후 어떤 값을 리턴할 수도 있다.



### 필드

객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태를 저장하는 곳이다.

#### 필드 선언

클래스 {} 블록 어디서든 존재할 수 있다. 생성자와 메소드 {} 블록 내부에는 선언될 수 없다. 생성자와 메소드 {} 내부에 선언된 것은 모두 **로컬 변수**가 된다.

```
타입 필드 [ = 초기값];
```

타입에는 기본 타입과 참조 타입이 모두 올 수 있다.

#### 필드 사용

필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다. 클래스 외부에서 사용할 경우 우선저긍로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.



### 생성자

new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다. new 연산자에 의해 생성자가 성공적으로 실행되면 힙(heap) 영역에 객체가 생성되고 객체의 주소가 리턴된다. 만약 생성자가 성공적으로 실행되지 않고 예외(에러)가 발생했다면 객체는 생성되지 않는다.

#### 기본 생성자

모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 클래스 내부에 생성자 선언을 생략했다면 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가시킨다. 

```
[public] 클래스() {}
```

클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public이 붙지 않는다.

그렇기 때문에 클래스에 생성자를 선언하지 않아도 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시킬 수 있다. 

```
Car myCar = new Car(); 
```

클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않는다.

#### 생성자 선언

```
클래스(매개변수선언, ...) {
	// 객체의 초기화 코드
}
```

생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다. 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

#### 필드 초기화

클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다. 객체 생성 시점에서 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야한다. 객체의 필드는 하나가 아니라 여러 개가 있고, 이 필드들을 모두 생성자에서 초기화한다면 생성자의 매개 변수의 수는 객체의 필드 수만큼 선언되어야 한다.

#### 생성자 오버로딩

다양한 방법으로 객체를 생성할 수 있는 **생성자 오버로딩**(Overloading)을 제공ㅎ한다. 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.

생성자 오버로딩 시 주의할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이라고 볼 수 없다.

```
Car(String model, Sring color) {...}
Car(String color, String model) {...} // 오버로딩이 아님
```

생성자가 오버로딩 되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출된 생성자를 결정한다.

#### 다른 생성자 호출(this())

생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할  수 있기에 생성자에서 다른 생성자를 호출할 때에는 this() 코드를 사용한다.

```
클래스([매개변수선언, ...]) {
	this(매개변수, ..., 값, ...);
	실행문;
}
```

this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다. 



### 메소드

객체의 동작에 해당하는 {} 블록을 말한다. 메소드를 호출하게 되면 {} 블록에 있는 모든 코드들이 일괄적으로 실행된다. 

#### 메소드 선언

메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)과 실행블록으로 구성된다. 메소드 선언부를 시그너처(signature)라고 한다

```
리턴타입 메소드이름([매개변수선언, ...]) {
	실행할 코드를 작성하는 곳
}
```

##### 리턴 타입

메소드가 실행 후 리턴하는 값의 타입을 말한다.  메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다. 리턴 타입이 있다고 해서 반드시 리턴값을 변수에 저장할 필요는 없다.

##### 메소드 이름

- 숫자로 시작하면 안 되고, $와 _를 제외한 특수문자 사용하지 말아야 한다.

- 관례적으로 메소드명은 소문자로 작성하나 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫 머리 글자는 대문자로 작성한다.

메소드명의 길이는 프로그램 실행과는 무관하니, 너무 짧게 주지 않도록 한다.

##### 매개 변수 선언

매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다. 매개값은 반드시 매개 변수의 타입에 부합되는 값이어야 한다.

##### 매개 변수의 수를 모를 경우

매개 변수를 배열 타입으로 선언하는 것이다.

```
int sum1(int[] values) {...}
```

배열로 넘겨줌으로서 배열의 항목들을 모두 전달할 수 있다. 배열의 항목 수는 호출될 때 결정된다.

배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.  매개 변수를 "..."를 사용해서 선언하게 되면, 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용한다.

```
int sum2(int ... values) {...}
```

#### 리턴(return)문

##### 리턴 값이 있는 메소드

메소드 선어네 리턴 타입이 있는 메소드는 반드시 return문을 사용해서 리턴값을 지정해야 한다. return문이 실행되면 메소드는 즉시 종료된다.

```
return 리턴값;
```

return문을 사용할 때 주의할 점은 return문 이후에 실행문이 오면 "Unreachable code"라는 컴파일 오류가 발생한다. return문 이후에 실행문은 결코 실행되지 않기 때문이다.

##### 리턴값이 없는 메소드(void)

void로 선어뇐 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.

#### 메소드 호출

클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다. 그 이유는 객체가 존재해야 메소드도 존재하기 때문이다.

##### 객체 내부에서 호출

```
메소드(매개값, ...);
```

메소드를 호출하고 리턴값을 받고 싶다면 다음과 같이 변수를 선언하고 대입하면 된다.

```
타입 변수 = 메소드(매개값, ...);
```

##### 객체 외부에서 호출

외부 클래스에서 메소드를 호출하려면 우선 클래스로부터 객체를 생성해야 한다. **메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않기 때문이다.**

```
클래스 참조변수 = new 클래스(매개값, ...);
```

객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호추할 수 있다. 도트 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드에 접근할 때 사용된다.

```
참조변수.메소드(매개값, ...);
타입 변수 = 참조변수.메소드(매개값,...);
```

#### 메소드 오버로딩

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(overloadiing)이라고 한다. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다.

메소드를 오버로딩할 때 주의할 점은 매개 변수의 타입과 개수, 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 메소드 오버로딩일고 볼 수 없다. 리턴 타입은 자바 가상 기계가 메소드를 선택할 때 아무런 도움을 주지 못한다. 

