### 객체 지향 프로그래밍

객체를 만들고 조립하여 완성된 프로그램을 만드는 기법을 **객체 지향 프로그래밍(OOP: Object Oriented Programming)**이라고 한다

집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방법으로 프로그램을 개발하는 기법이다

#### 객체란?

**물리적으로 존재하거나 추상적**으로 생각할 수 있는 것 중에서 **자신의 속성을 가지고 있고 다른 것과 식별 가능한 것**. 자바는 속성과 동작들을 각각 **필드(Field)**와 **메소드(method)**라고 부른다

객체 모델링(Object Modeling)은 현실 세계 객체의 속성과 동작을 추려내여 소프트웨어 객체의 필드와 메소드로 정의하는 과정이라고 볼 수 있다

#### 객체의 상호작용

객체들을 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작한다. 객체들 사이으 ㅣ상호작용 수단은 메소드이다. 객체가 다른 객체의 기능을 이용하는 것이 메소드 호출이다

메소드 호출은 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술하면 된다. 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다

```
리턴값 = 전자계산기객체.메소드(매개값1, 매개값2,...);
```

매개값은 메소드를 실행하기 위해 필요한 데이터이다.  예를 들어 30과 20을 주고 빼기 기능을 이용하다고 했을 때 30과 20은 빼기 기능의 매개값이다. 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는(리턴하는) 값이다.

```
int result = Calculator.minus(30, 20); // 리턴한 값을 int 변수에 저장
```

객체의 상호작용은 객체 간의 호출을 의미하며 <u>매개값과 리턴값을 통하여 데이터를 주고 받는다</u>.

####  객체 간의 관계

객체는 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류는 **집합 관계**, **사용 관계**, **상속 관계**가 있다.

집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다.

사용 관계는 객체 간의 상호작용을 말한다. 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다. (사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계라고 볼 수 있다.)

상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다. 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다

#### 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍의 특성으로는 캡슐화, 상속, 다형성을 들 수 있다.

- 캡슐화(Encapsulation)

객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. 자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 **접근 제한자(Access Modifier)**를 사용한다. <u>접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함로써 외부로부터 보호</u>한다.

- 상속(Inheritance)

일반적으로 상속은 부모가 가지고 있는 재산을 자신에게 물려주는 것을 말한다. 상위 객체는 자신이 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 개체가 사용할 수 있도록 해준다. 상위 객체를 재사용하여 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 반복된 코드의 중복을 줄여준다. 상위 객체의 수정으로 모든 하위 객체의 수정 효과를 가져오므로 유지 보수 시간을 최소화시켜주기도 한다. 

- 다형성(Polymorphism)

같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 객체에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다. 다형성의 효과로 객체는 부품화가 가능하다



### 객체와 클래스

메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 자바에서는 설계도가 **클래스(class)**이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스(instance)** 라고 한다. 클래스로부터 객체를 만드는 과정을 **인스턴스화**라고 한다. 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다. 

1. 클래스를 설계해야 한다.
2. 설계된 클래스를 가지고 사용할 객체를 생성해야 한다.
3. 생성된 객체를 이용하는 것이다.



### 클래스 선언

클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라 만들어야 한다.

| 번호 | 작성규칙                                | 예                  |
| ---- | --------------------------------------- | ------------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다      | Car.ShortsCar       |
| 2    | 첫 번째 글자는 숫자가 올 수 없다        | Car.3Car(x)         |
| 3    | '$', '_' 외의 특수문자는 사용할 수 없다 | $Car, _Car, @Car(x) |
| 4    | 자바 키워드는 사용할 수 없다            | int(x), for(x)      |

클래스 이름이 단일 단어라면 첫 자를 대문자로 하고 나머지는 소문자로 작성한다. 서로 다른 단어가 혼합된 이름을 사용한다면 각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례적이다.

일반적으로 솟 파일당 하나의 클래스를 선언한다.

파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.



### 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 new 연산자를 사용하면 된다.

new 연산자는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데 생성자는 클래스의 형태를 가지고 있다. new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 현실 세계에서 물건의 위치를 모르는 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. **그래서 new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다** 이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.

```
클래스 변수;
변수 = new 클래스();
```

```
클래스 변수 = new 클래스();
```

new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.

클래스는 라이브러리(API: Application Program Interface)용이고 다른 하나는 실행용이다. 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다. 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행 클래스이다. 실행 클래스는 프로그램의 실행 진입점인 main() 멧드를 제공하는 역할을 한다



### 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버 필드(Filed), 생성자(Constructor), 메소드(Method)가 있으며 생략되거나 복수 개가 될 수 있다. 

```
public class ClassName {
	
	// 필드
	int fieldName;
	
	// 생성자
	ClassName() {...}
	
	// 메소드
	void methodName() {...}
}
```



#### 필드

객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수와 비슷하나, 필드를 변수라고 부르지 않는다.  필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

#### 생성자

생성자는 new 연산자로 호출되는 특별한 중괄호 블록이다. 객체 생성 시 초기화를 담당하며 메소드를 호출해서 객체를 사용할 준비를 한다. 클래스 이름으로 되어 있고 리턴 타입이 없다.

#### 메소드

객체의 동작에 해당되는 중괄호 블록이다. 메소드를 호출하게 {} 블록에 있는 모든 코드들이 일관적으로 실행된다. 필드를 읽고 수정하는 여갈도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 객체 간의 데이터 전달 수단으로 사용되며 외부로부터 매개값을 받을 수 있고, 실행 후 어떤 값을 리턴할 수도 있다.