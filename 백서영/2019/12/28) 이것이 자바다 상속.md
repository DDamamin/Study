#### 상속 개념

현실에서 상속은(Inheritance)는 부모가 자식에게 물려주는 행위를 말한다. 자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용할 수 있다. 객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다.

상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다. 상속을 해도 부모 클래스의 모든 필드와 메소드를 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 defualt 접근 제한을 갖는 필드와 메소드도 상속 대사에서 제외된다.

상속을 이용하면 클래스의 수정을 최소화시킬 수 있다. 부모 클래스의 수정으로 모든 자식 클래스들의 수정 효과를 가져오기 때문에 유지 부소 시간을 최소화시켜준다.

#### 클래스 상속

자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 extends 뒤에 기술한다.

```java
class 자식클래스 extends 부모클래스 {
	// 필드
	// 생성자
	// 메소드
}
```

다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다. 여러 개의 부모 클래스를 상속할 수 없으므로 extnds 뒤에는 단 하나의 부모 클래스만 와야 한다

#### 부모 생성자 호출

자바에서도 자식 객체를 생성하면, **부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성**된다. 모든 객체는 클래스의 생성자를 호출해야만 생성된다. 그렇다면 부모 객체를 생성하기 위해 부모 생성자를 어디서 호출한 것일까? 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.

```java
public DmbCellPhone() {
	super();
}
```

첫 줄에 super(); 가 추가된 것을 볼 수 있다. super()는 부모의 기본 생성자를 호출한다. 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 된다.

```
자식클래스(매개변수선언, ...) {
	super(매개값, ...);
	...
}
```

super(매개값, ...)는 매개값의 타입과 일치하는 부모 생성자를 호출한다. 매개값의 타입과 일치하는 부모 생성자가 없을 경우 컴파일 오류가 발생한다. super(매개값, ..)가 생략되면 컴파일러에 의해 super()가 자동적으로 추가되기 때문에 부모의 기본 생성자가 존재해야 한다. 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 suepr(매개값,...)을 명시적으로 호출해야 한다. suepr(매개값, ..,)은 반드시 자식 생성자 첫 줄에 위치해야 한다.



#### 메소드 재정의

부모 클래스의 모든 메소드가 자식 클래스에 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다. 이 경우 상속된 일부 메소드를 자식 클래스에서 다시 수정해서 사용해야 한다. 자바는 이런 경우를 위해 메소드 오버라이딩(Overriding) 기능을 제공한다.

##### 메소드 재정의(@Override)

상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다. 메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에, 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.

- 부모의 메소드와 동일한 시그너처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다.
- 새로운 예외(Exception)를 thorw할 수 없다.

접근 제한을 더 강하게 오버라이딩할 수 없다는 것은 부모 메소드가 public 접근 제한을 가지고 있을 경우 오버라이딩하는 자식 메소드는 default나 private 접근 제한으로 수정할 수 없다는 뜻이다.  부모 메소드가 default 접근 제한을 가지면 재정의되년 자식 메소드는 default 또는 public 접근 제한을 가질 수 있다.

@Override 어노테이션은 생략해도 좋으나, 정화히 오버라이딩된것인지 컴파일러가 체크하기 땜누에 개발자의 시루를 줄여준다.

이클립스는 부모 메소드 중 하나를 선택해서 오버라이딩 메소드를 자동 생성해주는 기능이 있다.

1. 자식 클래스에서 오버라이딩 메소드를 작성할 위치로 입력 커서를 옮긴다.
2. 메뉴에서 [Source-Override/Implemetn Methods...]를 선택한다.
3. 부모 클래스에서 오버라이딩될 메소드를 선택하고 [OK] 버튼을 선택한다.

##### 부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용한다. 그러나 **자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여 부모 메소드를 호출**할 수 있다. super는 부모 객체를 참조하고 있기 때문에 **부모 메소드에 직접 접근**할 수 있다.

```java
super.부모메소드();
```



#### final 클래스와 final 메소드

final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. final 키워드는 해당 선언이 최종 상태이고, 결코 수정될 수 없음을 뜻한다. 필드 선언 시에 final이 지정되면 초기값 설정 후, 더 이상 값을 변경할 수 없다.

##### 상속할 수 없는 final 클래스

클래스를 선언할 때 final 키워드를 class 앞에 붙이면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. 즉 **final 클래스는 부모 클래스가 될 수 없어서 자식 클래스를 만들 수 없다는 것이다**.

```java
public final class 클래스 {...}
```

final 클래스의 대표적인 예는 자바 표준 API에서 제공하는 String 클래스이다.

```java
public final class String {...}
```

그래서 자식 클래스를 만들 수 없다.

##### 오버라이딩할 수 없는 final 메소드

메소드를 선언할 때 final 키워드를 붙이게 되면 이 메소드는 **최종적인 메소드이므로 오버라이딩(Overriding)할 수 없는 메소드**가 된다. 즉 **부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없다는 것이다**.

```java
public final 리턴타입 메소드([매개변수, ...]) {...}
```



##### protected 접근 제한자

접근 제한자는 public, protected, default, private와 같이 네 종류가 있다. protected는 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용한다. 자식 클래스일 경우에는 new 연산자를 사용해서 생성자를 직저 호출할 수는 없고, 자식 생성자에서 super()로 생성자를 호출할 수 있다.



#### 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉 부모 타입에 모든 자식 객체가 대입될 수 있다. 

예를 들어 자동차를 설계할 때 타이어 클래스 타입을 적용했다면 이 클래스를 상속한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.

타입 변환이란 **데이터 타입을 다른 데이터 타입으로 변환하는 행위**를 말한다. 클래스 타입의 변환은 **상속 관계에 있는 클래스 사이에서 발생**한다. 자식 타입은 부모 타입으로 자동 타입 변환이 가능하다.

##### 자동 타입 변환(Promotion)

프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.

```java
// 자동 변환 타입의 조건
부모클래스 변수 = 자식클래스타입;
```

자동 타입 변환의 개념은 <u>자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다</u>. 부모 타입으로 자동 타입 변환된 이후에는 **부모 클래스에 선언된 필드와 메소드만 접근이 가능**하다. 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다. 메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 대신 호출된다. 

##### 필드의 다형성

자식 타입으로 사용하면 될 것을 부모 타입으로 변환해서 사용하는 이유는 무엇일까? 그것은 다형성을 구현하는 기술적 방법 때문이다. 다형성이란 **동일한 타입을 사용하지만 다양한 결과가 나오는 성질**을 말하다.주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.

프로그램은 수많은 객체들이 서로 연결되고 각자의 역할을 하게 되는데, 이 객체들은 다른 객체로 교체될 수 있어야 한다. 새로 교체되는 객체는 기존 객체와 사용 방법은 동일하지만 실행 결과는 더 우수하게 나와야 할 것이다. 이것을 프로그래밍으로 구현하기 위해서는 상속과 오버라이딩, 그리고 타입 변환을 이용하는 것이다.

부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일할 것이고, 자식 클래스는 부모의 메소드를 오버라이딩(재정의)해서 메소드의 실행 내용을 변경함으로써 더 우수한 실행 결과가 나오게 할 수 있다. 그리고 자식 타입을 부모 타이븡로 변환할 수 있다.

##### 하나의 배열로 객체 관리

우리는 동일한 타입의 값들은 배열로 고나리하는 것이 유리하다는 것을 알고 있다. 

```java
class Car {
	Tire[] tires ={
		new Tire("1번", 1);
		new Tire("2번", 2);
		new Tire("3번", 3);
		new Tire("4번", 4);
	}
}
```

tire 배열의 각 항목은 Tire 타입으므로 자식 객체인 KunhoTire을 대입하면 자동 타입 변환이 발생하기 때문에 아무런 문제가 없다. 배열 타입은 Tire이지만 실제 저장 항목이 Tire의 자식 객체라면 모두 가능하다. 상속 관계에 있는 객체드을 배열로 관리하면 제어문에서 가장 많이 혜택을 본다.

##### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 가장 많이 발생한다. 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값을 지정하는 것이 정석이지만, 매개값을 다양화하기 위해 **매개 변수에 자식 타입 객체를 지정**할 수 있다.

```java
class Dirver {
	void drive(Vehicle vehicle) {
		vehicle.run();
	}
}
```

drive 메소드를 정상적으로 호출한다면 다음과 같을 것이다..

```java
Driver driver = new Driver();
Vehicle vehicle = new Vihicle();
driver.drive(vehicle);
```

만약 Vehicle의 자식 클래스인 Bus 객체를 drive() 메소드의 매개값으로 넘겨준다면 어떻게 될까? Vehicle을 상속받는 Bus  객체가 매개값으로 사용되면 자동 타입 변환이 발생한다.

```java
Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus);
// 자동 타입 변환 발생
// Vehicle vehicle = bus;
```

매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 **자식 객체까지도 매개값**으로 사용할 수 있다. 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다(매개 변수의 다형성). 자식 객체가 부모의 메소드를 재정의(오버라이딩)했다면 메소드 내부에서 메소드를 호출함으로써 메소드의 실행 결과는 다양해진다.

##### 강제 타입 변환

강제 타입 변환은 **부모 타입을 자식 타입으로 변환하는 것**을 말한다. 자식 타입이 부모 타입으로 자송 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.

```java
자식 클래스 변수 = (자식클래스) 부모클래스타입; // 자식 타입이 부모 타입으로 변환된 상태
```

자식 타입이 부모 타입으로 자동 변환되면, <u>부모 타입에 선언된 필드와 메소드만 사용한다는 제약 상황</u>이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.

##### 객체 타입 확인(instancof)

강제 타입 변환은 **자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능**하기 때문에 부모 타입의 변수가 부모 객체를 참조할 경우 자식 타입으로 변환할 수 없다.

```java
Parent parent = new Parent();
Child child = (Child) parent; // 강제 타입 변환 불가
```

부모 변수가 참조하는 객체가 부모 객체인지 자식 객체인지 확인하는 방법은 instanceof 연산자를 사용하면 된다.

instanceof 연산자의 좌항은 객체가 오고, 우항은 타입이 오는데, 좌항의 객체가 우항의 인스턴스이면 즉 우항의 타입으로 객체가 생성되었다면 true를 산출하고 그렇지 않으면 false를 산출한다

```java
boolean result = 좌항(객체) instanceof 우항(타입)
```

instanceof 연산자는 **매개값의 타입을 조사할 때 주로 사용**한다. 메소드 내에서 강제 타입 변환이 필요할 경우 반드시 매개값이 어떤 객체인이 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야 한다. 예외가 발생하면 프로그램은 즉시 종료되기 때문에 강제 타입 변환을 하기 전에 instanceof 연산자로 변환시킬 타입의 객체인지 조사해서 잘못된 매개값으로 인해 프로그램이 종료되는 것을 막아야 한다.



#### 추상 클래스

##### 추상 클래스의 개념

사전적 의미로 추상(abstract)는 실체 간에 공통되는 특성을 추출한 것을 말한다. 동물이나 회사는 구체적인 실체라기보다는 실체들의 공통되는 특성을 가지고 있는 추상적인 것이라고 볼 수 있다.

클래스에도 추상 클래스가 존재한다. **객체를 직접 생성할 수 있는 클래스를 실체 클래스**라고 한다면 이 **클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스**라고 한다. 추상 클래스가 부모이고 실체 클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다. 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다. **추상 클래스는 new 연산자를 사용해서 인스턴스를 생성시키지 못한다**.

```java
Animal animal = new Animal(); // (X)
```

추상 클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용된다. 코드로 설명하는 추상 클래스는 extends 뒤에만 올 수 있는 클래스이다.

```java
class Ant extends Animal {...} // (o)
```

##### 추상 클래스의 용도

실체 클래스들의 공통적인 특성(필드, 메소드)를 뽑아내어 추상 클래스로 만드는 이유가 무엇일까?

1. 실체 클래스들의 공통적인 필드와 메소드의 이름을 통일할 목적

   실체 클래스를 설계하는 사람이 여러 명일 경우, 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가지 수 있다. 동일한 데이터와 기능임에도 불구하고 이름이 다르다 보니, 객체마다 사용 방법이 달라진다. 추상 클래스를 설계하여 상속함으로써 **필드와 메소드 이름을 통일시킬 수 있다.**

2. 실체 클래스를 작성할 때 시간을 절약

   공통적인 필드와 메소드는 추상 클래스에 모두 선언해 두고, 실체 클래스마다 다른 점만 실체 클래스에 선언하게 되면 실체 클래스를 작성하는 데 시간을 절약할 수 있다. 코더가 작성해야 할 클래스가 다수이고, 이 클래스들이 동일한 필드와 메소드를 가져야 할 경우, 설계자는 이 내용들을 추려내어 추상 클래스로 설계 구격을 만드는 것이 좋다.

##### 추상 클래스 선언

추상 클래스를 선언할 때 클래스 선언에 abstract 키워드를 붙여야 한다. abstract를 붙이게 되면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.

```java
public abstract class 클래스 {
	// 필드
	// 생성자
	// 메소드
}
```

추상 클래스도 일반 클래스와 마찬가지로 필드, 생성자, 메소드 선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 **super(...)를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 한다**.

##### 추상 메소드와 오버라이딩

추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스이므로 실체 클래스의 멤버(필드, 메소드)를 통일화하는데 목적이 있다. 모든 실체들이 가지고 있는 메소드의 실행 내용이 동일하다면 추상 클래스에 메소들르 작성하는 것이 좋을 것이다. 하지만 메소드의 선언만 통일화하고, 실행 내용은 클래스마다 달라야 하는 경우가 있다.

이를 위해서 추상 클래스는 **추상 메소드**를 선언할 수 있다. **추상 메소드는 추상 클래스에서만 선언할 수 있는데, 메소드의 선언부만 있고 메소드 실행 내용인 중괄호 {}가 없는 메소드**를 말한다.  자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 하는데, 그렇지 않으면 컴파일 에러가 발생한다.

```java
[public | protected] abstract 리턴타입 메소드명(매개변수, ...);
```

일반 메소드 선언과의 차이점은 **abstract 키워드**가 붙어 있고 **메소드 중괄호 {}가 없다**는 것이다.

```java
public abstract class Aniaml {
	public abstract void sound();
}
```

자식 객체가 부모 타입로 자동 타입 변환되어 호출된다.

