#### 인스턴스 멤버와 this

인스턴스(instance) 멤버란 **객체(인스턴스)를 생성하고 사용할 수 있는** 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 인스턴스 필드와 메소드는 객체의 소속된 멤버이기에 객체 없이는 사용할 수 없다.  인스턴스 필드는 객체마다 따로 존재하고, 인스턴스 메소드는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유한다. 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 **객체 내부에서도 인스턴스 멤버에 접근하기 위해 this**를 사용할 수 있다.  this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다. 

```java
public class CarExample {
	public static void main(String[] args) {
		Car myCar = new Car("기아");
		Car yourCar = new Car("현대");
		
		myCar.run(); // 인스턴스 메소드
		yourCar.run(); // 인스턴스 메소드
	}
}
```



### 정적 멤버와 static

정적(static)은 '고정된'이란 의미를 가지고 있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.  정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속돈 멤버이기 때문에 클래스 멤버라고도 한다.

##### 정적 멤버 선언

필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다

```java
public class 클래스 {
	// 정적 필드
	static 타입 필드 [= 초기값];
	
	// 정적 메소드
	static 리턴 타입 메소드(매개변수선언, ...) { ... }
}
```

클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 역역에 적재할 때 클래스별로 관리된다. 클래스의 로딩이 끝나면 바로 사용할 수 있다.

##### 정적 멤버 사용

클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트(.) 연산자로 접근한다

```java
클래스.필드;
클래스.메소드(매개값, ...);
```

정적 필드, 정적 메소드는 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능하다. 하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다

##### 정적 초기화 블록

정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다. 인스턴스 필드는 생성자에서 초기화하지만, 정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다. 자바는 정적 필드의 복잡한 초기화 작업을 위해서 **정적 블록(static block)**을 제공한다.

```java
static {
	...
}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에서 여러 개가 선언되어도 상관없다. 클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다. 

##### 정적 메소드와 블록 선언 시 주의할 점

객체가 없어도 실행된다는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 객체 자신의 참조인 this 키워드도 사용이 불가능하다. 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

```java
static void Method3() {
	ClassName obj = new ClassName();
	obj.field1 = 10;
	obj.method1();
}
```

main() 메소드도 정적(static) 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main() 메소드에서 바로 사용할 수 없다.

##### 싱글톤(Singleton)

가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 한다.  싱글톤을 만드려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.생성자를 호출한 만큼 객체가 생성되기 때문이다. 생성자 앞에 private 접근 제한자를 붙여주면 된다.

자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다. 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다. 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다. 

```java
public clas 클래스 {
	// 정적 필드
	private static 클래스 singleton = new 클래스();
	
	// 생성자
	private 클래스() {}
	
	// 정적 메소드
	static 클래스 getInstance() {
		return signleton;
	}
}
```

외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다. 단 하나의 객체만 리턴하기 때문에 변수1과 변수2는 **동일한 객체를 참조**한다

```
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```



#### final 필드와 상수

##### final 필드

final 필드는 초기값이 저장되면 이것이 최종적인 값이 되면서 프로그램 실행 도중 수정할 수 없다는 것이다.

```java
final 타입 필드 = [=초기값];
```

final 필드의 초기값을 줄 수 있는 방법은 필드 선언 시에 주는 방법과 생성자에 주는 방법이다. 생성자는 final  필드의 최종 초기화를 마쳐야 하는데, 만약 초기화가 되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

##### 상수(static final)

불변의 값을 저장하는 필드를 자바에서는 상수(constant)라고 한다.  final 필드는 한 번 초기화하면 수정할 수 없는 필드인데 final 필드를 상수라고 부르지 않는다. 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띄고 있으며, 여러 가지 값으로 초기화될 수 없기 때문이다. **final 필드는 객체마다 저장**되고 생성자의 매개값을 통해어 어떤 값을 가질 수 있기 때문에 상수가 될 수 없다.

상수는 static 이면서 final 이어야 한다. static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다. 한 번 초기값이 저장되면 변경할 수 없다.

```java
static final 타입 상수 [=초기값];
```

초기값이 단순 값이라면 선언 시에 주는 것이 일반적이지만, 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final 타입 상수;
static  {
	상수 = 초기값;
}
```

상수 이름은 모두 대문자로 작성하는 것이 관례이다. 만약 서로 다른 단어가 혼합된 이름이라면 언더바(_)로 단어들을 연결해준다.



#### 패키지

클래스를 체계적으로 관리하지 않으면 클래스 간의 관계가 뒤엉켜서 복잡하고 난해한 프로글매이 되어 결국 유지 보수가 어렵게 된다.  자바에서는 클래스를 체계적으로 관리하기 위해 패키지(package)를 사용한다. 패키지의 물리적인 형태는 파일 시스템의 폴더이다. 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식한다. 클래스의 전체 이름은 "패키지명+클래스명"인데 패키지가 상, 하위로 구분되어 있다면 도트(.)를 사용해서 표현한다.

```
상위패키지.하위패키지.클래스
```

패키지가 중요한 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없기에 클래스를 이동할 경우에는 패키지 전체를 이동시켜야 한다.

##### 패키지 선언

패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성되는 폴더이다. 컴파일러는 클래스의 포함되어 있는 패키지 선언을 보고, 파일 시스템 폴더로 자동 생성시킨다.

```java
package 상위패키지.하위패키지;

public class ClassName {...}
```

- 숫자로 시작해서는 안되고, _, $를 제외한 특수 문자를 사용해서는 안 된다
- java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안 된다.
- 모두 소문자로 작성하는 것이 관례이다

##### import문

다른 패키지에 속하는 클래스를 사용하려면 패키지와 클래스를 모두 기술하거나 import문을 주로 사용한다

```
public class Car {
	com.hankook.Tire tire = new com.hankoook.Tire();
}
```

```
import com.hankoook.Tire;
[또는 import com.hankook.*;]
```

import 문이 작성되는 위치는 패키지 선언과 클래스 선언 사이이다. 패키지에 포함도니 다우싀 클래스를 사용해야 한다면 클래스별로 import문을 작성할 필요 없이 클래스 이름을 생략하고 대신 *를 사용해서 import문을 한 번에 작성하면 된다. 하위 패키지에 있는 클래스들도 사용하고 싶다면 import문을 하나 더 작성해야 한다. 



#### 접근 제한자

main() 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다. 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하기 못하도록 막아야 한다. 자바는 이러한 기능을 구현하기 위해 접근 제한자(Access Modifier)를 제공한다.

접근 제한자는 public, protected, default, private와 같이 네 가지 종류가 있다.

| 접근 제한 | 적용 대상                    | 접근할 수 없는 클래스                          |
| --------- | ---------------------------- | ---------------------------------------------- |
| public    | 클래스 필드, 생성자, 메소드  | 없음                                           |
| protected | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드, 생성자, 메소드         | 모든 외부 클래스                               |

##### 클래스의 접근 제한

클래스에 적용할 수 있는 접근 제한은 public과 default 단 두 가지이다

```java
// default 접근 제한
class 클래스 {...}

// public 접근 제한
public class 클래스 {...}
```

##### default 접근 제한

클래스를 선언할 때 public을 생략했다면 클래스는 default 접근 생성자를 가진다. **같은 패키지에서는 아무런 제한 없이 사용할 수 있지만 다른 패키지에서는 사용할 수 없도록 제한한다.**

##### public 접근 제한

public 접근 제한을 가지게 된다면 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다. 라이브러리 클래스들도 모두 public 접근 제한을 가지고 있다.

##### 생성자의 접근 제한

객체를 생성하기 위해서는 new 연산자로 생성자를 호출해야 하는데 생성자를 어디에서나 호출할 수 있는 것은 아니다. 생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능 여부가 결정된다.

```java
public class ClassName {
	// public 접근 제한
	public ClassName(...) {...}
	
	// protected 접근 제한
	protected ClassName(...) {...}
	
	// default 접근 제한
	ClassName(...) {...}
	
	// private 접근 제한
	private ClassName(...) {...}
}
```

클래스가 생성자를 선언하지 않으면 컴파일러에 의해 자동적으로 기본 생성자가 추가된다. 자동으로 생성된 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일한다.

##### 필드와 메소드의 접근 제한

클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 이것은 필드와 메솓드가 어떤 접근 제한을 갖느냐에 따라 결정된다

```java
// 필드 선언
[ public | protected | private ] [static] 타입 필드;
// 메소드 선언
[ public | protected | private ] [static] 리턴 타입 메소드(...) {...};
```



#### Getter와 Setter 메소드

일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다. 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨질 수 있기 때문이다. 객체 지향 프로그래밍에서는 메소드를 통하여 데이터를 변경하는 방법을 선호한다. **메소드는 매개값을 검증해서 유효한 값만 데이터로 저장**할 수 있기 때문이다. 이러한 역할을 하는 메소드가 Setter이다.

외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있다. 이런 경우에는 **메소드로 필드값을 가공한 후 외부로 전달**하면 된다. 이런 메소드가 바로 Getter이다.

클래스를 선언할 때 가능하다면 필드를 private로 선언해서 외부로부터 보호하고, 필드에 대한 Setter와 Getter 메소드를 작성해서 필드값을 안전하게 변경, 사용하는 것이 좋다.

```java
private 타입 fieldName;

// Getter
public 리턴 타입 getFieldName() {
    return fieldName;
}

// Setter
public void setFieldName(타입 fieldName) {
    this.fieldName = fieldName;
}
```

필드 타입이 boolean일 경우에는 Getter는 <u>get으로 시작하지 않고 is</u>로 시작하는 것이 관례이다.

외부에서 필드값을 읽을 수만 있고 변경하지 못하도록(읽기 전용) Getter 메소드만 선언해도 좋고, Setter 메소드를 private 접근 제한을 갖도록 선언해도 좋다. 



#### 어노테이션

어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다.  메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.

```java
@AnnotationName
```

- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
- 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예는 @Override 어노테이션이다. @Override는 메소드 선언 시 사용하는데, 메소드가 오버라이드(재정의) 된 것임으 컴파일러에게 알려주어 컴파이러가 오버라이드 검사를 하도록 해준다. 정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다.

##### 어노테이션 타입 정의와 적용

어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다. 다음과 같이 @interface를 사용해서 어노테이션을 정의하며, 그 뒤에 사용할 어노테이션 이름이 온다.

```java
public @interface AnnotatioName {
}
```

어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다. 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

```java
public @interface AnnotationName {
	타입 elementName() [default 값];
}
```

앨리먼트의 타입으로는 int나 double과 같은 기본 데이터 타입이나 String, 열거 타입, Class 타입, 그리고 이들의 배열 타입을 사용할 수 있다. 

##### 어노테이션 적용 대상

어노테이션을 적용할 수 있는 대상은 java.lang.annotation.EementType 열거 상수로 다음과 같이 정의되어 있다.

| ElementType 열거 상수 | 적용 대상                     |
| --------------------- | ----------------------------- |
| TYPE                  | 클래스, 인터페이스, 열거 타입 |
| ANNOTATION_TYPE       | 어노테이션                    |
| FIELD                 | 필드                          |
| CONSTRUCTOR           | 생성자                        |
| METHOD                | 메소드                        |
| LOCAL_VARIABLE        | 로컬 변수                     |
| PACKAGE               | 패키지                        |

어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다. @Target의 기본 엘리먼트인 value는 ElementType 배열을 같으로 정한다. 

##### 어노테이션 유지 정책

사용 용도에 따라 @AnnotationName을 어느 범위까지 유지할 것이지 지정해야 한다. 소스상에만 유지할 건지, 컴파일된 클래스까지 유지할 것인지, 런타임 시에도 유지할 건지를 지정해야 한다. 어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수로 정의되어 있다.

| RetentionPolicy 열거 상수 | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| SOURCE                    | 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. |
| CLASS                     | 바이트 코드 파일까지 어노테이션 정보를 유지. 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다. |
| RUNTIME                   | 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해셔 런타임 시 어노테이션 정보 얻을 수 있다. |

리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다. 리플렉션을 이요해서 런타임 시에 어노테이션 정보를 얻으려면 어노테이션 유지 정책을 RUNTIME으로 설정해야 한다.