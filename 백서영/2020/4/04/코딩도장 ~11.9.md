# 코딩도장 ~11.9

**리스트, 튜플, range, 문자열**은 모두 같은 값이 연속적(sequence)으로 이어져 있는데 이것들을 시퀀스 자료형(sequence types)라고 부른다.

시퀀스 자료형의 가장 큰 특징은 **공통된 동작과 기능을 제공**한다. 시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(elememt)라고 부른다.

시퀀스 객체 안에 특정 값이 있는지 확인하는 방법

- 값 in 시퀀스객체

```python
>>> a = list(range(0, 100, 10))
>>> 30 in a
True
>>> 100 in a
False
```

시퀀스 객체에 in 연산자를 사용했을 때 특정 값이 있으면 True, 없으면 False

in 앞에 not을 붙이면 특정 값이 없는지 확인

```python
>>> a = list(range(0, 100, 10))
>>> 100 not in a
True
>>> 30 not in a
False
```

튜플, range 문자열도 같은 방법으로 활용할 수 있다.

```python
>>> 43 in (38, 11, 43, 62, 19)
True
>>> 1 in range (10)
True
>>> 'P' in 'Hello, Python'
True
```

시퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있다.

- 시퀀스객체 1 + 시퀀스객체 2

```python
>>> a = [0, 10, 20, 30]
>>> b = [9, 8, 7, 6]
>>> a + b
[0, 10, 20, 30, 9, 8, 7, 6]
```

단, 시퀀스 자료형 중에서 **range는 + 연산자로 객체를 연결할 수 없다**.

```python
>>> range(0, 10) + range(10, 20)
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    range(0, 10) + range(10, 20)
TypeError: unsupported operand type(s) for +: 'range' and 'range' 
```

range를 리스트 또는 튜플로 만들어서 연결하면 된다.

```python
>>> list(range(0, 10)) + list(range(10, 20))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> tuple(range(0, 10)) + tuple(range(10, 20))
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
```

문자열은 + 연산자로 여러 문자열을 연결하 수 있다.

```python
>>> 'Hello, ' + 'world!'
'Hello, world!'
```

문자열에 정수를 연결하려면 에러가 뜬다(정수를 문자열로 변환할 수 없어서 TypeError 발생) str을 사용해서 숫자(정수, 실수)를 문자열로 변환하면 된다.

'문자열' + str(실수)

'문자열' + str(정수)

```python
>>> 'Hello, ' + str(10)
'Hello, 10'
>>> 'Hello, ' + str(1.5)
'Hello, 1.5'
```

시퀀스 객체를 반복할려면 * 연산자를 사용한다. * 연산자는 퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만든다(0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없다).

- 시퀀스객체 \* 정수
- 정수 \* 시퀀스객체

```python
>>> [0, 10, 20, 30] * 3
[0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30]
```

range는 객체 연결 및 반복(*)도 불가능하다

문자열도 * 연산자를 이용해 반복할 수 있다.



시퀀스 객체에 있는 요소의 개수(길이)를 구할 때는 len 함수를 사용

- len(시퀀스객체)

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> len(a)
10
```

```python
>>> b = (38, 76, 43, 62, 19)
>>> len(b)
5
```

range에 len 함수를 사용하면 숫자가 생성되는 개수를 구한다

```python
>>> len(rnage(0, 10, 2))
5
```

문자열도 시퀀스 자료형이므로 len 함수를 사용하면 된다.

```python
>>> hello = 'Hello, world!'
>>> len(hello)
13
```

문자열의 길이는 **공백을 포함**하나, 문자열을 묶은 **따옴표는 제외**한다.

UTF-8에서 한글 글자 하나는 3바이트로 표현하므로, '안녕하세요'가 차지하는 실제 바이트 ㅅ는 15바이트이다

```python
>>> hello = '안녕하세요'
>>> len(hello.encode('utf-8'))
15
```



시퀀스 객체의 각 요소는 순서가 정해져 있으며, 이 순서를 **인덱스**라고 부른다. 시퀀스 객체에 대괄호[]를 붙이고 [] 안에 각 요소의 인덱스를 지정하면 해당 요소에 접근할 수 있다.

- 시퀀스객체[인덱스]

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[0]    # 리스트의 첫 번째(인덱스 0) 요소 출력
38
>>> a[2]    # 리스트의 세 번째(인덱스 2) 요소 출력
53
>>> a[4]    # 리스트의 다섯 번째(인덱스 4) 요소 출력
19
```

시퀀스 객체의 인덱스는 항상 0부터 시작한다. 튜플, range, 문자열도 [] 에 인덕스를 지정하면 해당 요소를 가져올 수 있다.

range도 인덱스로 접근할 수 있다.

```python
>>> r = range(0, 10, 2)
>>> r[2]
4
```

시퀀스 객체에 인덱스를 지정하지 않은 상태는 **해당 객체 전체**를 뜻한다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> a
[38, 21, 53, 62, 19]
```

시퀀스 객체에서 [ ] (대괄호)를 사용하면 실제로는 \__getitem__  메서드를 호출하여 요소를 가져온다. 직접 호출해서 가져올 수도 있다.

- 시퀀스 객체.__getitem__\(인덱스)

```python
>>> a = [38, 21, 53, 62, 19]
>>> a.__getitem__(1)
21
```

시퀀스 객체의 인덱스 음수를 지정하면 뒤에서부터 요소에 접근하게 된다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[-1]   # 리스트의 뒤에서 첫 번째(인덱스 -1) 요소 출력
19
>>> a[-5]   # 리스트의 뒤에서 다섯 번째(인덱스 -5) 요소 출력
38
```

-1은 뒤에서 첫번째, -5는 뒤에서 다섯 번째 요소이다

시퀀스 객체는 요소의 개수가 정해져 있는데 범위를 넘어간 인덱스에 접근하려면 IndexError가 발생한다. 마지막 요소의 인덱스는 시퀀스 객체의 요소의 개수보다 1 작다.

시퀀스 객체에 인덱스를 -1로 접근하는 방법 말고 다른 방법으로 마지막 요소에 접근하려면

- 시퀀스객체[len(시퀀스객체) -1]

```python
>>> a[len(a) -1]
19
```



시퀀스 객체는 [ ]로 요소에 접근한 뒤 =로 값을 할당한다.

- 시퀀스객체[인덱스] = 값

```python
>>> a = [0, 0, 0, 0, 0]    # 0이 5개 들어있는 리스트
>>> a[0] = 38
>>> a[1] = 21
>>> a[2] = 53
>>> a[3] = 62
>>> a[4] = 19
>>> a
[38, 21, 53, 62, 19]
>>> a[0]
38
>>> a[4]
19
```

튜플의 [ ] 에 인덱스를 지정한 뒤 값을 할당하면 에러가 발생한다.

```python
>>> b = (0, 0, 0, 0, 0)
>>> b[0] = 38
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    b[0] = 38
TypeError: 'tuple' object does not support item assignment 
```

range와 문자열도 안에 저장된 요소를 변경할 수 없다.

```python
>>> r = range(0, 10, 2)
>>> r[0] = 3
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    r[0] = 3
TypeError: 'range' object does not support item assignment 
>>> hello = 'Hello, world!'
>>> hello[0] = 'A'
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    hello[0] = 'A'
TypeError: 'str' object does not support item assignment 
```

시퀀스 자료형 중에서 튜플, range, 문자열은 읽기 전용이다.



요소 삭제는 del 뒤에 삭제할 요소를 지정해주면 된다.

- del 시퀀스객체[인덱스]

```python
>>> a = [38, 21, 53, 62, 19]
>>> del a[2]
>>> a
[38, 21, 62, 19]
```

튜플, range, 문자열은 요소 삭제가 불가능하다.





시퀀스 자료형은 슬라이스라는 기능을 자주 사용하는데 슬라이스(slice)는 말 그대르 시퀀스 객체의 일부를 잘라낸다.

- **시퀀스객체[시작인덱스:끝인덱스]**

다음은 리스트의 일부분을 잘라 새 리스트를 만든다.

```python
>>> a= [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[0:4]
[0, 10, 20, 30]
```

[ ] 안에 시작 인덱스와 끝 인덱스를 지정하면 해당 범위 리스트를 잘라서 가져올 수 있다. 끝 인덱스는 가져오려는 범위에 포함되지 않기에 실제 가져오려는 인덱스보다 1을 더 크게 지정해야 한다.

a[1:1]처럼 시작 인덱스와 끝 인덱스를 같은 숫자로 지정하면 아무것도 가져오지 않는다.

슬라이스를 했을 때 실제 가져오는 요소는 **시작 인덱스부터 끝 인덱스 -1까지**이다.



슬라이스는 인덱스의 증가폭을 지정하여 범위 내에서 인덱스를 건너뛰며 요소를 가져올 수 있다. **인덱스의 증가폭이지 요소의 값 증가폭은 아니다**.

- 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:8:3]    # 인덱스 2부터 3씩 증가시키면서 인덱스 7까지 가져옴
[20, 50]
```

인덱스 증가폭을 지정하더라도 **가져오려는 인덱스(끝 인덱스 -1)를 넘어설 수 없다**



슬라이스를 사용할 때 시작 인덱스와 끝 인덱스를 생략할 수도 있다. 시퀀스 객체의 길이를 몰라도 되기 때문에 자주 쓰인다.

- 시퀀스객체[:끝인덱스]

- 시퀀스객체[시작인덱스:]

- 시퀀스객체[:]

  리스트 전체를 가져온다



시작 인덱스나 끝 인덱스를 생략하면서 인덱스를 증가ㅍ폭을 지정하면

- 시퀀스객체[:끝인덱스:증가폭]

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[:7:2]    # 리스트의 처음부터 인덱스를 2씩 증가시키면서 인덱스 6까지 가져옴
[0, 20, 40, 60]
```

- 시퀀스객체[시작인덱스::증가폭]

```python
>>> a[7::2]    # 인덱스 7부터 2씩 증가시키면서 리스트의 마지막 요소까지 가져옴
[70, 90]
```

- 시퀀스객체[::증가폭]

  리스트 전체에서 인덱스 0부터 증가하면서 가져옴

```python
>>> a[::2]     # 리스트 전체에서 인덱스 0부터 2씩 증가시키면서 요소를 가져옴
[0, 20, 40, 60, 80]
```

- 시퀀스객체[::]

  리스트 전체를 가져온다

슬라이스의 인덱스 증가폭을 **음수로 지정할 때 끝인덱스보다 시작인덱스를 더 크게 지정해야 한다.** 끝 인덱스는 가져오려는 범위에 포함되지 않는다.

시작인덱스, 끝인덱스를 생략하면서 인덱스 증가폭을 -1로 지정하면 리스트를 반대로 뒤집는다.

```python
>>> a[::-1]
[90, 80, 70, 60, 50, 40, 30, 20, 10, 0]
```



len을 응용하려면

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[0:len(a)]    # 시작 인덱스에 0, 끝 인덱스에 len(a) 지정하여 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[:len(a)]     # 시작 인덱스 생략, 끝 인덱스에 len(a) 지정하여 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

끝인덱스를 포함하지 않으므로 1을 빼주면 안된다.



튜플, range, 문자열도 시퀀스 자료형이므로 리스트와 같은 방식으로 슬라이스를 사용할 수 있다.

- 튜플[시작인덱스::끝인덱스]
- 튜플[시작인덱스::인덱스증가폭]

```python
>>> b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)
>>> b[4:7]     # 인덱스 4부터 6까지 요소 3개를 가져옴
(40, 50, 60)
>>> b[4:]      # 인덱스 4부터 마지막 요소까지 가져옴
(40, 50, 60, 70, 80, 90)
>>> b[:7:2]    # 튜플의 처음부터 인덱스를 2씩 증가시키면서 인덱스 6까지 가져옴
(0, 20, 40, 60)
```

range에 슬라이스를 사용하면 지정된 범위의 숫자를 생성하는 range 객체를 새로 만든다.

- range 객체[시작인덱스::끝인덱스]
- range 객체[시작인덱스::끝인덱스::인덱스증가폭]

```python
>>> r = range(10)
>>> r
range(0, 10)
>>> r[4:7]     # 인덱스 4부터 6까지 숫자 3개를 생성하는 range 객체를 만듦
range(4, 7)
>>> r[4:]      # 인덱스 4부터 9까지 숫자 6개를 생성하는 range 객체를 만듦
range(4, 10)
>>> r[:7:2]    # 인덱스 0부터 2씩 증가시키면서 인덱스 6까지 숫자 4개를 생성하는 range 객체를 만듦
range(0, 7, 2)
```

range는 요소가 모두 표시되지 않고 생성 범위만 표시된다. 문자열도 시퀀스 자료형이므로 슬라이스를 사용할 수 있다. **문자열은 문자 하나가 요소이므로 문자 단위로 잘라서 새 문자열을 만든다.**

- **문자열[시작인덱스:끝인덱스]**
- **문자열[시작인덱스:끝인덱스:인덱스증가폭]**

```python
>>> hello = 'Hello, World!'
>>> hello[2:9]
'llo, Wo'
>>> hello[2:]
'llo, World!'
>>> hello[:9:2]
'Hlo o'
```



slice 객체를 사용해서 시퀀스 객체(시퀀스 자료형으로 만든 번수)를 잘라낼 수도 있다.

슬라이스객체 = slice(끝인덱스)

슬라이스객체 = slice(시작인덱스, 끝인덱스)

슬라이스객체 = slice(시작인덱스, 끝인덱스, 인덱스증가폭)

시퀀스객체[슬라이스객체]

시퀀스객체.\__getitem__(슬라이스객체)

```python
>>> range(10)[slice(4, 7, 2)]
range(4, 7, 2)
>>> range(10).__getitem__(slice(4, 7, 2))
range(4, 7, 2)
```

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> s = slice(4, 7)    # 인덱스 4부터 6까지 자르는 slice 객체 생성
>>> a[s]
[40, 50, 60]
>>> r = range(10)
>>> r[s]
range(4, 7)
>>> hello = 'Hello, world!'
>>> hello[s]
'o, '
```



시퀀스 객체는 슬라이스로 범위를 지정하면서 여러 요소에 값을 할당할 수 있다.

- 시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a', 'b', 'c']    # 인덱스 2부터 4까지 값 할당
>>> a
[0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]
```

원래 있던 리스트가 변경되며 **새 리스트는 생성되지 않는다.**

**요소의 개수를 맞추지 않아도 알아서 할당**한다. 할당할 요소 개수가 적으면 그만큼 리스트의 요소 개수도 줄어든다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a']    # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어듦
>>> a
[0, 10, 'a', 50, 60, 70, 80, 90]
```

할당할 요소 개수가 많으면 그만큼 리스트의 요소 개수도 늘어난다

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어남
>>> a
[0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]
```

끝인덱스를 정해주지 않으면 아래와 같다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:] = ['a', 'b']
>>> a
[0, 10, 'a', 'b']
```

- 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:8:2] = ['a', 'b', 'c']    # 인덱스 2부터 2씩 증가시키면서 인덱스 7까지 값 할당
>>> a
[0, 10, 'a', 30, 'b', 50, 'c', 70, 80, 90]
```

인덱스 증가폭을 지정했으면 **슬라이스 범위의 요소 개수와 할당할 요소 개수가 정화히 일치해야 한다.**

**튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없다.**



슬라이스 삭제는 del 뒤에 삭제할 범위를 지정해주면 된다.

- del 시퀀스객체[시작인덱스:끝인덱스]

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> del a[2:5]    # 인덱스 2부터 4까지 요소를 삭제
>>> a
[0, 10, 50, 60, 70, 80, 90]
```

del로 요소를 삭제하면 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않는다.

인덱스 증가폭을 지정하면 인덱스를 건너뛰면서 삭제. 튜플, range, 문자열은 del로 슬라이스를 삭제할 수 없다.