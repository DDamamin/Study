# 문제 도메인 모델

API는 어떤 문제를 해결하거나 어떤 작업을 실행하기 위해서 개발된다. 따라서 API는 해당 문제에 대해 쉽게 납득 가능한 해결책을 제시해야 한다. 그리고 실제 문제 도메인 모델 내에서도 제대로 동작해야한다. 즉 문제 영역에 관한 잘된 추상화를 제공하고 해당 문제를 표현하는 핵심을 객체로 표현한다. 이렇게 한다면 사용자는 쉽게 API를 이해하고 사용할 수 있다. 보통 사용자는 그 문제에대한 경험이나 관련된 지식을 가지고 있기 때문이다.

## 훌륭한 추상화 제공

- 논리적인 추상화를 제공하고 문제를 해결할 수 있어야 한다
- 문제 해결은 저수준의 코드를 감추고 상위 수준의 코드를 통해 이루어져야 한다
- API는 개발자가 아닌 일반인이 읽어도 인터페이스의 동작 방식을 이해해야 한다
- 클래스들은 고유 목적을 가지고 있어야 한다
- 클래스와 메서드의 이름을 통해 그 목적이 드러나야 한다

## 핵심 객체 모델링

문제 도메인의 핵심 객체를 모델링한다

- 주요 객체를 식별한다
- 각 객체들이 제공해야하는 동작과 서로의 연결 관계를 확인한다



---



# 구체적인 구현 숨기기

API의 큰 목적은 내부 로직을 변경 시 클라이언트에게 영향을 미치지 않는 것이다

따라서 내부적인 구현 내용을 숨겨야 한다

## 물리적 은닉

- 코드가 private이다 즉 코드가 숨겨져 있다
- 선언과 정의를 분리한다

## 논리적 은닉

- 캡슐화를 이용한다

- 맴버 변수를 숨기고 getter와 setter를 지원한다
  - 유효성 체크
  - 지연된 평가
    변수의 값을 계산하는 것은 많은 비용을 발생시킬수 있으므로 실제로 값이 필요할 때까지 연산을 지연시킨다
  - 캐싱
    자주 계산되는 값을 매번 계산할 필요없이 미리 저장하고 요청시 재연산 없이 바로 리턴
  - 추가 연산
  - 알림
    값이 변경되는 것에 대해 알림을 발생시켜 GUI에 반영한다는 등의 역할을 수행할 수 있다
  - 디버깅이 용이하다
  - 스레드 동기화에 용이하다
  - 접근 제어
    읽기 전용, 쓰기 전용, 접근 불가로 만들 수 있다
  - 관계 유지
    멤버 변수의 역할과 목적이 임의로 변경되지 않게 한다

- 메서드 구현을 숨긴다
  - 사용하든데 필요한 부분을 제외한 곳을 모두 private으로 둔다
  - 사람들은 헤더파일을 볼 수 있으므로 private 멤버를 완벽히 숨길 수 없다
    - pimple 관용법을 이용한다

- 클래스의 구현을 숨긴다
  - c++의 클래스는 모두 public이다 내부 로직을 구현하기 위한 클래스를 숨길 필요가 있다
  - 클래스를 클래스 안에 선언하는 방법으로 해결 가능하다



---



# 작게 완성하기

좋은 API는 최소한의 크기로 가능한 작아야 한다

## 지나친 약속은 금지

- public 인터페이스는 계속해서 제공하겠다는 약속이다
- 최소한의 약속을 위해 다음 유혹을 버리자
  - 보다 더한 보편화는 필요한 순간이 오지 않을 수 있다
  - 만약 그런 날이 온다면 우리는 API에 더 많은 지식을 쌓을 것이고 다른 해결책을 내놓을 것이다.
  - 추가 기능이 필요하다면 복잡한 곳보다는 간단한 API에 추가하는 것이 쉽다

## 가상 함수의 추가는 신중하게

- 가상 함수 단점
  - base 클래스를 변경시 가상 함수를 이용하는 클라이언트에게 좋지 않은 영향을 미칠 수 있다
  - 클라이언트는 의도하지 않은 방향으로 이를 이용할 수 있다
  - 클라이언트가 고려하지 못한 안정성 문제가 생길 수 있다 
  - 가상 함수는 오버헤드가 발생한다
  - vtable 포인터 크기 때문에 객체 크기가 증가한다
  - 가상 함수 호출은 vtable에서 정수의 offset으로 표현되므로 순서가 바뀌거나 추가 등의 행위가 기존의 코드를 재컴파일 하게 만든다
  - 가상 함수는 인라인 될 수 없다
  - override 키워드를 사용하지 않을 시 가상 함수 인지 확인이 불가능해 오버로드하는 것 조차 어려울 수 있다
- 가상 함수를 사용해도 되는 때
  - 파생 클래스와 베이스 클래스 간에 "~는 ~이다" 관계가 확실할 때

- 가상 함수를 대체하는 법
  - 템플릿 메서드 디자인 패턴을 이용
    - NVI (비가상 인터페이스 이디엄) 패턴



---



# 쉬운 사용성

별다른 문서를 참조하지 않아도 API 메서드의 기호를 쉽게 알아볼 수 있도록 만들어야 한다
새로운 상황을 만드는 것보다 기존에 사용한 모델과 패턴을 이용해 사용자가 익숙한 상황에 놓여 작업에 집중할 수 있도록 한다

그럼에도 문서화는 중요하고 누구나 예제 코드를 보고 어떻게 적용하면 될지 이해하게 하는 것이 좋다

## 한눈에 들어오는

- 사용자가 API를 어떻게 사용해야할 지 한눈에 이해할 수 있는 것
- 직관적이고 논리적인 객체 모델을 만드는 것
- 이름만 봐도 대략 그 기능이 짐작이 되도록 하는 것
  - 축약된 형태를 가능하면 피한다

## 잘못 사용하기도 어렵게

- 잘못된 파라미터 혹은 사용해서는 안되는 값을 파라미터로 전달하는 경우를 막는다
  - 같은 타입을 가진 여러개의 파라미터는 잘 못된 순서로 전달할 여지가 있다
    enum이나 새로운 클래스로 이용하여 컴파일러가 오류를 알릴 수 있도록 한다

## 일관성 있는

- 일관성 장점
  - 더 적은 것만을 기억하면 된다
  - 사용자가 쉽게 익숙해 진다
- 일관성을 가져야하는 것
  - 일관성 있는 명명 규칙
  - 파라미터의 순서
  - 표준 패턴
  - 의미론적 메모리 모델
  - 예외 및 오류 처리
  - 등등등

- 일관성을 가지는 법
  - 다형성을 적용한다
  - 템플릿을 이용한다

## 수직적인

- 무엇이 수직적인가?
  - 두 벡터가 수직인 것은 직각이고 내적은 0이다
  - 서로에게 영향을 미치지 않는다
  - 서로에게 영향을 미치지 않는 메서드
- 중요한 요소
  - 중복을 제거
    - 같은 정보가 두가지 이상의 방법으로 반복되지 않게 한다
  - 독립성 증가
    - 노출되는 개념에 중복된 의미가 없어야한다
    - 중첩되는 개념들은 기반 컴포넌트로 분리한다

## 견고한 자원 할당

- c++의 대부분의 버그는 잘못된 포인터나 참조를 사용하는 데서 발생한다
  - NULL 포인터 참조
  - 메모리 이중 해제
  - 유효하지 않은 메모리 접근
  - 할당자 혼용 (malloc으로 할당하고 delete로 해제하는 등)
  - 잘못된 배열 해제
  - 메모리 누수
- 해결법
  - 공유 포인터 (레퍼런스 카운트)
  - 약한 포인터
  - 범위 한정 포인터 (unique 포인터)
  - 팩토리 패턴 등으로 위와 같은 스마트 포인터로 접근을 강제한다

## 플랫폼 독립성

- #if / #ifdef와 같은 코드를 public 헤더에 포함하지 않는다
- 플랫폼별 코드가 달라지는 경우 플랫폼에 종속적인 코드는 .cpp파일 등 내부로 숨긴다

- 예로 스마트폰에 GPS를 이용한다
  모든 폰에 GPS가 있는 건 아닐거다
  이때 폰의 기종마다 #if / #define한 것을 pubilc 헤더에 포함하는 것 보다
  GPS를 가지는 지 확인하는 함수를 하나 추가하고
  내부에서 #if / #define으로 처리하는 것이 좋다



# 느슨한 연결

- 연결과 결합
  - 연결 : 각각의 컴포넌트가 다른 컴포넌트에 얼마나 의존하는지
  - 결합 : 컴포넌트의 다양한 함수들이 얼마나 논리 정연한지 또는 강하게 연관되어 있는지

하나의 컴포넌트 안의 멤버들은 연관성이 크고 각각의 컴포넌트가 독립적여 사용자가 각각의 컴포넌트를 따로따로 이해하도록 하며 분리해서 유지보수할 수 있게 한다
즉 연결을 느슨하게 결합은 강하게한다

## 이름만 연결

- 클래스 A가 클래스 B의 어떤 멤버와 크기에 대해 알필요 없고 이름만 필요한 경우
  - include 없이 전방 선언으로 물리적인 연결을 없앨 수 있다

## 클래스 연결 줄이기

- 멤버 함수 대신 비멤버, 비프렌드 함수를 이용한다

- 예시

  ```C++
  class MyObject {
  public:
      std::string GetName() const;
  private:
      std::string mName;
  };
  void PrintName(const MyObject &obj) const;
  ```

  위의 예시 코드에서 PrintName 자유 함수는 MyObject의 멤버가 아니므로 public 멤버에만 접근 가능하다 
  이로서 MyObject의 내부 코드가 변경되어도 문제가 발생할 확률이 낮아진다
  이때 MyObject와 PrintName의 개념적 관계를 위해 같은 네임스페이스 안에 선언할 수 있다

## 의도적인 중복

- 코드의 재사용은 재사용된 코드 간의 연결 관계를 만든다

- 심각한 연결 관계를 없애기 위해 적은 양의 코드를 중복하는 것이 더 좋을 수 있다

- 예

  - 채팅의 로그를 남기는 기능을 만들고자 한다
    채팅을 하는 유저에 대한 유저 클래스와 채팅의 로그를 남기는 로그 클래스가 있다
    로그 클래스는 누가 채팅을 하는지 남겨야 하므로 유저 클래스를 받아와야 한다
    이때 보통의 경우 유저의 이름만 필요하므로 유저 클래스 전체보다 유저 이름만 받아올 수도 있다
    이렇게 바꾸면 유저의 이름을 중복하게 되지만 의존성을 낮출 수 있다

    ```C++
    //바꾸기 전
    bool ChatLog::AddMessage(cosnt ChatUser &user, const std::string &msg);
    //바꾼 후
    bool ChatLog::AddMessage(const std::string &user, const std::string &msg);
    ```

    단 이렇게 바꾼 후 만약 유저의 이름을 바꾸는 기능을 추가한다면 다시 위의 상황을 바꾸어야 할 것이다
    그렇지 않고 이름이 바뀔때마다 이 사실을 유저 클래스에서 전달 받는 방식을 사용할 경우 의존성은 더욱 높아지만 할 것이다

## 매니저 클래스

- 같은 역할을 하나 그 세세한 부분이 다른 여러개의 클래스를 다루는 것은 복잡하고 여러개의 클래스와 의존적인 연결 관계를 형성한다
- 매니저 클래스를 이용하고 적당한 추상화 기법을 사용하면 컨트롤 클래스는 매니저 클래스에만 의존하면 되며 새로운 클래스를 추가할 때에도 컨트롤 클래스에 의존하지 않고 추가할 수 있다

## 콜백과 옵저버, 알림

- 의존성을 낮추기 위해 콜백이나 옵저버 ,알림을 이용할 수 있다
- 몇가지 고려사항이 있다
  - 재진입성
    사용자의 콜백함수가 콜백함수를 실행하는 API를 다시 호출할 수도 있다
  - 수명 관리
    클라이언트는 관련 API를 끊고 객체를 제거하는 등의 행위를 하도록 해야한다
  - 이벤트 순서
    이벤트 순서는 사용자가 알기 힘들고 이는 꽤 골치 아픈 상황을 만든다
    따라서 일관적인 이벤트 순서와 그 기능을 해야한다
  - 위의 것들을 고려하며 일관적이고 안정적인 API 설계를 해야하며 API 문서를 통해 이를 언급하거나 기능들을 안정적인 몇가지만 노출 시킨다

## 안정화와 문서화, 테스트

- 안정적이고 미래 증명적이여야한다
- 이전 버전과 다음 버전이 호환되어야 하며 혼란스럽지 않아야 한다
- 각 API가 어떤 행동을 하며 어떻게 하면 최적화해 사용가능하고 어떤 조건에서 오류가 발생하는지를 명확히 이해가능한 문서를 제공해야한다
- 새로운 변경이 발생하더라도 기존의 유즈 케이스에 영향을 미치지 않도록 API 구현 코드를 사용해 확장된 자동화 테스트 프로세스르 갖추어야한다



---



# 참고

## 함수 포인터와 functional

함수 포인터는 콜백 함수등을 만들때 꽤 유용하게 쓰인다
`반환타입 (*포인터변수명)(인자);`
이런식으로 선언이 가능하다

이러한 함수 포인터는 C에서 부터 존재해왔다
그런데 C++에서는 클래스가 생기면서 함수의 호출 방식에 thiscall이라는 방식이 생겼다
이는 함수에 this포인터를 bind 해준다
따라서 위의 함수 포인터로는 this포인터를 bind할 수가 없어 멤버 함수는 위의 방식으로 접근할 수 없다
그래서 이를 위해 여러 문법이 지원된다

`반환타입 (클래스명::*포인터변수명)(인자);`
클래스명이 범위지정연산자와 함께 쓰였다
`포인터변수명 = &클래스명::멤버함수명;`
위의 방식으로 멤버함수를 가리키게 할 수 있다

여기까지 해도 아직 this포인터가 bind된 것이 아니다
따라서 함수를 호출시 아래와 같은 방법을 사용한다
`(객체.*포인터변수명)(인자)`;

c++에서는 이를 위해 .\*이나 ->\* 새로운 연산자를 만들었다
하지만 위의 방식은 기존의 함수포인터와 통합되진 않는다
따라서 C++11에서는 functional이라는 새로운 기능을 지원한다

```C++
#include <functional>

class A(){
public:
    void func1();
}

void func2(int a);

int main() {
    std::function<void()> pFunc1;
    std::function<void(int)> pFunc2;
    
    A a;
    
    pFunc1 = std::bind(&A::func1, &a);
    pFunc2 = std::bind(func2);
    
    pFunc1();
    pFunc2(5);
    
    return 0;
}
```

functional을 이용하면 위처럼 세련되게 처리가 가능하다

심지어 매개변수의 순서를 바꿀 수 있다

``` C++
#include <functional>

void func(int a, int b);

int main() {
    std::function<void()> pFunc;

    pFunc = bind(func, std::placeholders::2, std::placeholders::1);
    
    func(5, 10);	//함수 호출 1번
    pFunc1(10, 5);	//함수 호출 2번
        
    return 0;
}
```

위의 코드에서 함수 호출 1번이나 함수 호출 2번이나 같은 순서로 매개변수가 전달 된다
함수 호출 2번의 경우 bind할때 placeholders로 그 순서를 바꿨기 때문이다



이러한 기능은 boost라이브러리에 있다가 C++11이 되면서 표준으로 넘어왔다