## 목차

[변수](#변수)

[데이터 타입](#데이터-타입)

[함수](#함수)

[주석](#주석)
__주석 부분 내용은 문서화 주석 관련 내용을 추가해야함__

[제어문](#제어문)

[소유권](#소유권)

---



## 변수

### 변수

- `let`을 통해 선언 가능하다

- 기본 변수는 불변하다
  - 안정성과 손쉬운 동시성
- `mut`을 통해 변경가능한 변수로 선언이 가능하다

### 상수와의 차이점

- 상수는 `const`로 선언한다

- 상수는 `mut`키워드를 사용할 수 없다
- 상수는 프로그램이 실행되는 시간 내내 유효하다

### Shadowing

- 이전에 선언한 변수의 이름과 같은 이름의 새 변수를 선언시
- 해당 변수명은 두 번째 변수의 값을 가진다

- `mut`을 사용했을 때 보다 타입에서 자유롭게 사용 가능하다

``` Rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
}
```

위의 코드는 문제 없음

```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
}
```

위의 코드는 컴파일 에러



---



## 데이터 타입

- 모든 값들은 어떤 __타입__을 가진다
- Rust는 어떤 데이터 타입인지 알아야 어떻게 다룰지 안다
- Rust에게 어떤 형태의 데이터 타입인지 알려주어야한다
  Rust는 강한 정적 타입 언어이다
  컴파일러는 값에 따라 타입을 추론할 수 있다
- 타입은 크게 스칼라, 컴파운드(복합) 둘로 나뉜다





### 스칼라

- __하나의 값__으로 표현되는 타입이다

- __정수형__,  __부동소수점 숫자__, __Boolean__, 문자 네 종류의 스칼라가 존재



#### 정수형

| Length | Signed | Unsigend |
| ------ | ------ | -------- |
| 8bit   | i8     | u8       |
| 16bit  | i16    | u16      |
| 32     | i32    | u32      |
| 64     | i64    | u64      |
| arch   | isize  | usize    |

`arch`는 컴퓨터 환경에 따라 달라진다
32bit 아키텍처에서는 32bit를
64bit아키텍처에서는 64bit를 가진다

Rust의 정수형 리터럴은 다음 표와 같다

| 정수 리터럴              | 예시        |
| ------------------------ | ----------- |
| Decimal(10진수)          | 98_222      |
| Hex(16진수)              | 0xff        |
| Octal(8진수)             | 0o77        |
| Binaray(2진수)           | 0b1111_0000 |
| Btye(바이트 `u8`만 해당) | b'A'        |

`57u8`와 같은 타입 접미사와 `_`를 이용한 시각적 구분을 허용한다

일반적으로 32bit와 64bit 모두 `i32`가 가장 빠르므로 `i32`를 주로 이용



#### 부동 소수점 타입

소수점을 가지는 두 가지 기본 타입이 존재한다
`f32`,   `f64`

`f64`가 `f32`와 대략 비슷한 속도를 내면서도 정밀한 표현이 가능하다
따라서 부동 소숫점 의 기본 타입은 `f64`



#### Boolean 타입

true와 false 두 가지의 값만 가지며 `bool`로 명시한다



#### 문자 타입

`char`를 이용해 표현하며 Unicode Scalar를 표현한다
스트링은 큰 따옴표로 `char`타입은작은 따옴표로 표현한다





### 컴파운드

- 컴파운드 타입 혹은 복합 타입이라 불린다
- 다양한 값을 하나의 타입으로 묶는다
- 기본 타입으로 __튜플__과 __배열__이 있다



#### 튜플

다양한 타입의 몇 개의 숫자를 집합시켜 하나의 타입으로 만드는 일반적인 방법이다

괄호 안에 콤마로 구분되는 값들의 목록을 작성하여 튜플을 만든다

``` Rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

변수 `tup`에 튜플 전체가 bind 된다
튜플의 값을 빼내기 위해서는 튜플의 값을 구조 해체하는 방법과 `.`을 통해 튜플의 요소에 직접적으로 접근하는 것이다

아래는 구제 해제를 통해 튜플의 값을 빼내는 방법이다

``` Rust
fn main() {
    let tup = (500, 6.4, 1);
    
    let (x, y, z) = tup;
}
```

아래는 `.`을 통해 요소에 직접 접근하는 방법이다

```Rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    
    let five_hundred = x.0;
    
    let six_point_four = x.1;

    let one = x.2;
    
}
```

튜플 `x`를 만들고 이의 각 요소들을 그들의 색인을 통해 접근하여 새 변수를 만든다
첫 번째 index은 0이다



#### 배열

배열의 모든 요소는 같은 타입이다
Rust는 고정된 배열 길이를 가진다
물론 stack에 할당된다
가변 길이는 벡터를 사용하면 된다

대괄호 안에 값들을 콤마로 구분하여 나열해 배열을 만든다

```Rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

index를 통해 배열의 요소에 접근할 수 있다
첫 번째 index은 0이다

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

아래의 코드는 배열의 범위를 벗어난 요소에 접근하려고 한다

```Rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

컴파일은 성공하나 실행하면 오류가 난다

index를 이용하여 요소에 접근하려고 하면 Rust는 지정한 index가 배열의 길이보다 작은지 확인한다
만약 index가 길이보다 길면 Rust는 오류와 함께 종료되는 데 이를 패닉(panic)한다라고 한다



---



## 함수

- `fn`키워드를 통해 선언이 가능하다

- Rust는 함수 이름 명명 규칙을 snake_case를 사용한다

- 중괄호 스코프로 함수의 범위를 알려준다

- 함수가 정의된 위치와는 상관없다

  ```Rust
  fn main() {
      another_function();
  }
  fn another_function(){
      ...
  }
  ```



### 함수 매개변수

함수는 매개변수를 가지는 형태로 선언될 수 있다

```Rust
fn main() {
    another_function(5);
}
fn another_function(x: i32){
    ...
}
```

매개변수는 반드시 타입을 정의해야 한다



### 구문과 표현식

__구문__은 어떤 명령들의 나열로 값을 반환하지 않는 동작을 수행한다
__표현식__은 결과를 산출해낸다

`let y = 6;`은 변수를 만들고 값을 할당하는 __구문__이다

따라서 다음과 같은 코드는 에러가 존재한다

```Rust
fn main() {
	let x = (let y = 6);
}
```

`5 + 6`과 같은 코드는 `11`이라는 값을 산출하는 코드로 __표현식__이다
표현식은 종결을 나타내는 세미콜론을 사용하지 않는다

표현식은 구문의 일부분일 수 있다
`let y = 6;`여기서 표현식은 `6`이 있다

새로운 범위를 생성하는 block`{}`은 표현식이다
따라서 다음과 같은 코드가 가능하다

```Rust
fn main() {
    let x = 5;
    let y = {
        let x = 3;
        x + 1
    };
}
```

`y`에는 4가 bound된다
`x + 1`줄의 마지막에 세미콜론이 없어 표현식이 되고 이는 결과를 산출한다 즉, 반환 값을 가진다



### 함수의 본문

함수는 본문을 가지며 구문과 표현식으로 이루어진다
함수의 본문은 함수의 block`{}`에 존재한다



### 반환 값을 가지는 함수

함수가 반환하는 타입은 명시해야한다
이는 `->`위에 선언할 수 있다

```Rust
fn five() -> i32 {
    5
}
```

반환 값은 함수 본문의 마지막 표현식일 수 있고 `return`키워드를 사용하여 함수로부터 일찍 반환할 수 있다

반환하지 않는 것은 비어있는 튜플`()`로 표시된다



---



## 주석

컴파일러가 무시하는 내용이다
소스코드의 부연 설명이나 임시로 코드를 동작하지 않게 할 때 사용한다

```Rust
//여기는 주석 입니다
//한 줄 주석입니다

/*
	여러줄
	주석 입니다
*/
```



---



## 제어문

실행 흐름을 제어할 수 있는 문법이다
조건문`if`와 반복문`loop, `while`, `for`가 있다



### if 표현식

조건에 따라 분기할 수 있게 한다

```Rust
if 조건 {
    코드 블록
}
```

위와 같은 형태를 띈다
조건에는 `bool`타입의 값이 온다

`else` 와 `else if`를 이용하여 조건에 해당하지 않았을 경우에 실행할 코드 블록을 지정할 수 있다

```Rust
if 조건1 {
    코드 블록1
} else if 조건2 {
    코드 블록2
} else if 조건3 {
    코드 블록3
} else {
    코드 블록4
}
```

__if__ 조건1을 만족하면 코드블록1을 수행한다
__else if__ 그렇지 않고 조건2를 만족하면 코드블록2를 수행한다
__else if__ 그렇지 않고 조건3를 만족하면 코드블록3를 수행한다
__else__ 그렇지 않으면 코드블록4를 수행한다

else if와 else는 존재할 수도 존재하지 않을 수도 있으며 else if는 여러개가 존재할 수 있다
단 else if가 존재시 else는 무조건 존재해야 한다

각각의 경우의 수를 갈래(arms)라 부른다



__`let`구문에서 `if`사용하기__

if 표현식이므로 let구문에서 사용가능하다

```Rust
let condition =  true;
let number = if condition {
    5
} else {
    6
};
```

단 이때 컴파일시 `number`의 타입은 확정되어야 하므로 각 arms가 산출하는 값의 타입은 같아야 한다



### 반복문과 반복

반복문은 코드블록을 반복하여 수행한다

__`loop`로 코드의 반복 수행__
그만두라는 명시하여 알려주기 전까지 반복 수행한다

```Rust
loop {
    println!("again!");
}
```

위의 코드는  그만두라는 코드가 없으므로 무한 반복한다
`break`이라는 키워드로 언제 멈추어야하는지 명시할 수 있다



---



## 소유권



### 소유권

소유권 규칙

1. 러스트의 각각의 값들은 해당값의 __오너(owner)__라 불리는 변수를 가진다
2. 한번에 하나의 오너만 존재한다
3. 오너가 소코프를 벗어날 때, 값은 버려진다(dropped)

스택에 저장되었다가 스코프를 벗어날 때 스택으로부터 팝 된다
하지만 힙에 저장되는 데이터들은 런타임 중에 운영체제에게 요청되고 사용이 끝나면 메모리를 운영체제에게 반납한다
Rust가 아닌 언어들은 GC가 계속해서 사용하지 않는 메모리를 찾고 반납한다 GC가 없는 언어는 프로그래머가 직접 반납해야하며 이는 실수를 야기해 오류가 발생할 문제가 크다

Rust는 변수가 소속되어 있는 스코프를 벗어나면 자동으로 반납된다
Rust는 내부적으로 스코프를 벗어나면 drop이라는 함수를 호출해 반납한다

String은 힙 영역을 이용하는 대표적인 데이터 타입이다

```Rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

위의 코드를 컴파일 하면 에러 메세지를 보게 된다

s1의 소유권이 s2로 넘어갔기 때문에 더 이상 s1은 유효하지 않기 때문이다
이러한 일어난 것은 얕은 복사를 하기 때문이다

`let s2 = s1;`은 s1이 힙영역 데이터이니 이의 주소를 그대로 가리킨다
즉 s1과 s2 모두 같은 메모리를 가진다 이것이 얕은 복사이다
이때 s1과 s2 모두 스코프를 벗어나면 같은 메모리가 중복하여 drop되는 현상이 발생하고 이는 보안 취약성 문제를 일으킬 가능성이 크다

그렇다면 깊은 복사 즉 s2가 s1가 가리키는 메모리의 모든 데이터를 s2가 새로 복사하면 어떨까? 이는 너무 느리게 만들 것이다

따라서 소유권이 s1에서 s2로 넘어가며 s1은 더 이상 유효하지 않은 방법을 rust는 택했다



어떤 값을 스택에 올릴 수 있을 까?

- `u32`를 비롯한 모든 정수형 타입들
- `bool`타입
- `f64`를 비롯한 모든 부동 소수점 타입들
- `copy`가 가능한 타입으로만 구성된 튜플
- `copy`트레잇



__`깊은 복사하기`__

그렇다면 힙에 저장되는 변수를 깊은 복사하는 방법은 없을까?

`clone`이라는 공용 메소드를 통해 이를 해결할 수 있다



__`소유권과 함수`__

함수의 매개변수로 변수를 넘기는 것 또한 소유권이 이동합니다

```Rust
fn main() {
    let s = String::from("hello"); //s가 스코프에 들어옴, 소유권을 가짐
    func(s);					   //s의 값이 이동하면서 s는 소유권을 잃음
    //println!("{}",s);			     s는 더 이상 유효하지 않아 오류
}								   //s가 스코프를 나감
fn func(some_string: String) {	   //some_string이 소유권을 가짐
    println!("{}",some_string);
}									//some_string의 값이 drop됨
```



__`반환 값과 스콮`__

값의 반환도 소유권을 이동시킨다

```Rust
fn main() {
    let s1 = func1();
    let s2 = String::from("hello");
    let s3 = func2(s2);
}
fn func1() -> String {
    let s = String::from("hello");
    s
}
fn func2(s: String) -> String {
    s
}
```

func1의 s는 반환값을 통해 소유권을 넘겨줌으로 main 스코프가 끝날때 drop합니다



### 참조자와 빌림

함수가 매번 소유권을 가져갔다가 반환할 때 돌려주는 것은 불편하고 많은 매개변수를 가졌을 때의 해결 방법은 더욱 골치 아파진다

이럴때 사용할 수 있는 것이 참조자이다

```Rust
fn main() {
    let s1 = String::from("hello");
    let len = get_length(&s1);
    
    println!("{}의 길이 : {}",s1, len);
}
fn get_length(s: &String) -> usize {
    s.len()
}
```

여기서 눈여겨 볼 것은 매개변수로 `&s1`을 넘기고 `&String`타입을 받았다는 것이다

`&`기호가 참조자이다 소유권을 넘기지 않고 참조할 수 있도록 한다

![참조 도식화](./참조.svg)

이렇게 참조자를 이용해 소유권을 가져오지 않는 것을 `빌림`이라 한단

__`가변 참조자`__

```Rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

위와 같이 값을 변경할 수 있는 가변 참조자를 만들 수 있다

다만 가변 생성자는 특정한 스코프에서 특정 데이터에 대해 가변 참조자를 하나만 만들 수 있다

즉 아래와 같은 코드는 오류를 만든다

```Rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
```

아래의 코드도 오류를 만든다

```Rust
let mut s = String::from("hello");

let r1 = &s; // 문제 없음
let r2 = &s; // 문제 없음
let r3 = &mut s; // 큰 문제
```

여러 두개 이상의 포인터가 같은 데이터에 접근하고
그 중 하나라도 데이터를 쓸 수 있다면
컴파일 오류를 만든다



