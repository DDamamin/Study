## 목차

[변수](#변수)

[데이터 타입](#데이터-타입)

[함수](#함수)

[주석](#주석)
__주석 부분 내용은 문서화 주석 관련 내용을 추가해야함__

---



## 변수

### 변수

- `let`을 통해 선언 가능하다

- 기본 변수는 불변하다
  - 안정성과 손쉬운 동시성
- `mut`을 통해 변경가능한 변수로 선언이 가능하다

### 상수와의 차이점

- 상수는 `const`로 선언한다

- 상수는 `mut`키워드를 사용할 수 없다
- 상수는 프로그램이 실행되는 시간 내내 유효하다

### Shadowing

- 이전에 선언한 변수의 이름과 같은 이름의 새 변수를 선언시
- 해당 변수명은 두 번째 변수의 값을 가진다

- `mut`을 사용했을 때 보다 타입에서 자유롭게 사용 가능하다

``` Rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();
}
```

위의 코드는 문제 없음

```rust
fn main() {
    let mut spaces = "   ";
    spaces = spaces.len();
}
```

위의 코드는 컴파일 에러



---



## 데이터 타입

- 모든 값들은 어떤 __타입__을 가진다
- Rust는 어떤 데이터 타입인지 알아야 어떻게 다룰지 안다
- Rust에게 어떤 형태의 데이터 타입인지 알려주어야한다
  Rust는 강한 정적 타입 언어이다
  컴파일러는 값에 따라 타입을 추론할 수 있다
- 타입은 크게 스칼라, 컴파운드(복합) 둘로 나뉜다





### 스칼라

- __하나의 값__으로 표현되는 타입이다

- __정수형__,  __부동소수점 숫자__, __Boolean__, 문자 네 종류의 스칼라가 존재



#### 정수형

| Length | Signed | Unsigend |
| ------ | ------ | -------- |
| 8bit   | i8     | u8       |
| 16bit  | i16    | u16      |
| 32     | i32    | u32      |
| 64     | i64    | u64      |
| arch   | isize  | usize    |

`arch`는 컴퓨터 환경에 따라 달라진다
32bit 아키텍처에서는 32bit를
64bit아키텍처에서는 64bit를 가진다

Rust의 정수형 리터럴은 다음 표와 같다

| 정수 리터럴              | 예시        |
| ------------------------ | ----------- |
| Decimal(10진수)          | 98_222      |
| Hex(16진수)              | 0xff        |
| Octal(8진수)             | 0o77        |
| Binaray(2진수)           | 0b1111_0000 |
| Btye(바이트 `u8`만 해당) | b'A'        |

`57u8`와 같은 타입 접미사와 `_`를 이용한 시각적 구분을 허용한다

일반적으로 32bit와 64bit 모두 `i32`가 가장 빠르므로 `i32`를 주로 이용



#### 부동 소수점 타입

소수점을 가지는 두 가지 기본 타입이 존재한다
`f32`,   `f64`

`f64`가 `f32`와 대략 비슷한 속도를 내면서도 정밀한 표현이 가능하다
따라서 부동 소숫점 의 기본 타입은 `f64`



#### Boolean 타입

true와 false 두 가지의 값만 가지며 `bool`로 명시한다



#### 문자 타입

`char`를 이용해 표현하며 Unicode Scalar를 표현한다
스트링은 큰 따옴표로 `char`타입은작은 따옴표로 표현한다





### 컴파운드

- 컴파운드 타입 혹은 복합 타입이라 불린다
- 다양한 값을 하나의 타입으로 묶는다
- 기본 타입으로 __튜플__과 __배열__이 있다



#### 튜플

다양한 타입의 몇 개의 숫자를 집합시켜 하나의 타입으로 만드는 일반적인 방법이다

괄호 안에 콤마로 구분되는 값들의 목록을 작성하여 튜플을 만든다

``` Rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

변수 `tup`에 튜플 전체가 bind 된다
튜플의 값을 빼내기 위해서는 튜플의 값을 구조 해체하는 방법과 `.`을 통해 튜플의 요소에 직접적으로 접근하는 것이다

아래는 구제 해제를 통해 튜플의 값을 빼내는 방법이다

``` Rust
fn main() {
    let tup = (500, 6.4, 1);
    
    let (x, y, z) = tup;
}
```

아래는 `.`을 통해 요소에 직접 접근하는 방법이다

```Rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    
    let five_hundred = x.0;
    
    let six_point_four = x.1;

    let one = x.2;
    
}
```

튜플 `x`를 만들고 이의 각 요소들을 그들의 색인을 통해 접근하여 새 변수를 만든다
첫 번째 index은 0이다



#### 배열

배열의 모든 요소는 같은 타입이다
Rust는 고정된 배열 길이를 가진다
물론 stack에 할당된다
가변 길이는 벡터를 사용하면 된다

대괄호 안에 값들을 콤마로 구분하여 나열해 배열을 만든다

```Rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

index를 통해 배열의 요소에 접근할 수 있다
첫 번째 index은 0이다

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

아래의 코드는 배열의 범위를 벗어난 요소에 접근하려고 한다

```Rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

컴파일은 성공하나 실행하면 오류가 난다

index를 이용하여 요소에 접근하려고 하면 Rust는 지정한 index가 배열의 길이보다 작은지 확인한다
만약 index가 길이보다 길면 Rust는 오류와 함께 종료되는 데 이를 패닉(panic)한다라고 한다



---



## 함수

- `fn`키워드를 통해 선언이 가능하다

- Rust는 함수 이름 명명 규칙을 snake_case를 사용한다

- 중괄호 스코프로 함수의 범위를 알려준다

- 함수가 정의된 위치와는 상관없다

  ```Rust
  fn main() {
      another_function();
  }
  fn another_function(){
      ...
  }
  ```



### 함수 매개변수

함수는 매개변수를 가지는 형태로 선언될 수 있다

```Rust
fn main() {
    another_function(5);
}
fn another_function(x: i32){
    ...
}
```

매개변수는 반드시 타입을 정의해야 한다



### 구문과 표현식

__구문__은 어떤 명령들의 나열로 값을 반환하지 않는 동작을 수행한다
__표현식__은 결과를 산출해낸다

`let y = 6;`은 변수를 만들고 값을 할당하는 __구문__이다

따라서 다음과 같은 코드는 에러가 존재한다

```Rust
fn main() {
	let x = (let y = 6);
}
```

`5 + 6`과 같은 코드는 `11`이라는 값을 산출하는 코드로 __표현식__이다
표현식은 종결을 나타내는 세미콜론을 사용하지 않는다

표현식은 구문의 일부분일 수 있다
`let y = 6;`여기서 표현식은 `6`이 있다

새로운 범위를 생성하는 block`{}`은 표현식이다
따라서 다음과 같은 코드가 가능하다

```Rust
fn main() {
    let x = 5;
    let y = {
        let x = 3;
        x + 1
    };
}
```

`y`에는 4가 bound된다
`x + 1`줄의 마지막에 세미콜론이 없어 표현식이 되고 이는 결과를 산출한다 즉, 반환 값을 가진다



### 함수의 본문

함수는 본문을 가지며 구문과 표현식으로 이루어진다
함수의 본문은 함수의 block`{}`에 존재한다



### 반환 값을 가지는 함수

함수가 반환하는 타입은 명시해야한다
이는 `->`위에 선언할 수 있다

```Rust
fn five() -> i32 {
    5
}
```

반환 값은 함수 본문의 마지막 표현식일 수 있고 `return`키워드를 사용하여 함수로부터 일찍 반환할 수 있다

반환하지 않는 것은 비어있는 튜플`()`로 표시된다



---



## 주석

컴파일러가 무시하는 내용이다
소스코드의 부연 설명이나 임시로 코드를 동작하지 않게 할 때 사용한다

```Rust
//여기는 주석 입니다
//한 줄 주석입니다

/*
	여러줄
	주석 입니다
*/
```



---



## 제어문

실행 흐름을 제어할 수 있는 문법이다
조건문`if`와 반복문`loop, `while`, `for`가 있다



### if 표현식

조건에 따라 분기할 수 있게 한다

```Rust
if 조건 {
    코드 블록
}
```

위와 같은 형태를 띈다
조건에는 `bool`타입의 값이 온다

`else` 와 `else if`를 이용하여 조건에 해당하지 않았을 경우에 실행할 코드 블록을 지정할 수 있다

```Rust
if 조건1 {
    코드 블록1
} else if 조건2 {
    코드 블록2
} else if 조건3 {
    코드 블록3
} else {
    코드 블록4
}
```

__if__ 조건1을 만족하면 코드블록1을 수행한다
__else if__ 그렇지 않고 조건2를 만족하면 코드블록2를 수행한다
__else if__ 그렇지 않고 조건3를 만족하면 코드블록3를 수행한다
__else__ 그렇지 않으면 코드블록4를 수행한다

else if와 else는 존재할 수도 존재하지 않을 수도 있으며 else if는 여러개가 존재할 수 있다
단 else if가 존재시 else는 무조건 존재해야 한다

각각의 경우의 수를 갈래(arms)라 부른다



__`let`구문에서 `if`사용하기__

if 표현식이므로 let구문에서 사용가능하다

```Rust
let condition =  true;
let number = if condition {
    5
} else {
    6
};
```

단 이때 컴파일시 `number`의 타입은 확정되어야 하므로 각 arms가 산출하는 값의 타입은 같아야 한다



### 반복문과 반복

반복문은 코드블록을 반복하여 수행한다

__`loop`로 코드의 반복 수행__
그만두라는 명시하여 알려주기 전까지 반복 수행한다

```Rust
loop {
    println!("again!");
}
```

위의 코드는  그만두라는 코드가 없으므로 무한 반복한다
`break`이라는 키워드로 언제 멈추어야하는지 명시할 수 있다













