# 문제 도메인 모델

API는 어떤 문제를 해결하거나 어떤 작업을 실행하기 위해서 개발된다. 따라서 API는 해당 문제에 대해 쉽게 납득 가능한 해결책을 제시해야 한다. 그리고 실제 문제 도메인 모델 내에서도 제대로 동작해야한다. 즉 문제 영역에 관한 잘된 추상화를 제공하고 해당 문제를 표현하는 핵심을 객체로 표현한다. 이렇게 한다면 사용자는 쉽게 API를 이해하고 사용할 수 있다. 보통 사용자는 그 문제에대한 경험이나 관련된 지식을 가지고 있기 때문이다.

## 훌륭한 추상화 제공

- 논리적인 추상화를 제공하고 문제를 해결할 수 있어야 한다
- 문제 해결은 저수준의 코드를 감추고 상위 수준의 코드를 통해 이루어져야 한다
- API는 개발자가 아닌 일반인이 읽어도 인터페이스의 동작 방식을 이해해야 한다
- 클래스들은 고유 목적을 가지고 있어야 한다
- 클래스와 메서드의 이름을 통해 그 목적이 드러나야 한다

## 핵심 객체 모델링

문제 도메인의 핵심 객체를 모델링한다

- 주요 객체를 식별한다
- 각 객체들이 제공해야하는 동작과 서로의 연결 관계를 확인한다



---



# 구체적인 구현 숨기기

API의 큰 목적은 내부 로직을 변경 시 클라이언트에게 영향을 미치지 않는 것이다

따라서 내부적인 구현 내용을 숨겨야 한다

## 물리적 은닉

- 코드가 private이다 즉 코드가 숨겨져 있다
- 선언과 정의를 분리한다

## 논리적 은닉

- 캡슐화를 이용한다

- 맴버 변수를 숨기고 getter와 setter를 지원한다
  - 유효성 체크
  - 지연된 평가
    변수의 값을 계산하는 것은 많은 비용을 발생시킬수 있으므로 실제로 값이 필요할 때까지 연산을 지연시킨다
  - 캐싱
    자주 계산되는 값을 매번 계산할 필요없이 미리 저장하고 요청시 재연산 없이 바로 리턴
  - 추가 연산
  - 알림
    값이 변경되는 것에 대해 알림을 발생시켜 GUI에 반영한다는 등의 역할을 수행할 수 있다
  - 디버깅이 용이하다
  - 스레드 동기화에 용이하다
  - 접근 제어
    읽기 전용, 쓰기 전용, 접근 불가로 만들 수 있다
  - 관계 유지
    멤버 변수의 역할과 목적이 임의로 변경되지 않게 한다

- 메서드 구현을 숨긴다
  - 사용하든데 필요한 부분을 제외한 곳을 모두 private으로 둔다
  - 사람들은 헤더파일을 볼 수 있으므로 private 멤버를 완벽히 숨길 수 없다
    - pimple 관용법을 이용한다

- 클래스의 구현을 숨긴다
  - c++의 클래스는 모두 public이다 내부 로직을 구현하기 위한 클래스를 숨길 필요가 있다
  - 클래스를 클래스 안에 선언하는 방법으로 해결 가능하다



---



# 작게 완성하기

좋은 API는 최소한의 크기로 가능한 작아야 한다

## 지나친 약속은 금지

- public 인터페이스는 계속해서 제공하겠다는 약속이다
- 최소한의 약속을 위해 다음 유혹을 버리자
  - 보다 더한 보편화는 필요한 순간이 오지 않을 수 있다
  - 만약 그런 날이 온다면 우리는 API에 더 많은 지식을 쌓을 것이고 다른 해결책을 내놓을 것이다.
  - 추가 기능이 필요하다면 복잡한 곳보다는 간단한 API에 추가하는 것이 쉽다

## 가상 함수의 추가는 신중하게

- 가상 함수 단점
  - base 클래스를 변경시 가상 함수를 이용하는 클라이언트에게 좋지 않은 영향을 미칠 수 있다
  - 클라이언트는 의도하지 않은 방향으로 이를 이용할 수 있다
  - 클라이언트가 고려하지 못한 안정성 문제가 생길 수 있다 
  - 가상 함수는 오버헤드가 발생한다
  - vtable 포인터 크기 때문에 객체 크기가 증가한다
  - 가상 함수 호출은 vtable에서 정수의 offset으로 표현되므로 순서가 바뀌거나 추가 등의 행위가 기존의 코드를 재컴파일 하게 만든다
  - 가상 함수는 인라인 될 수 없다
  - override 키워드를 사용하지 않을 시 가상 함수 인지 확인이 불가능해 오버로드하는 것 조차 어려울 수 있다
- 가상 함수를 사용해도 되는 때
  - 파생 클래스와 베이스 클래스 간에 "~는 ~이다" 관계가 확실할 때

- 가상 함수를 대체하는 법
  - 템플릿 메서드 디자인 패턴을 이용
    - NVI (비가상 인터페이스 이디엄) 패턴



---



# 쉬운 사용성

별다른 문서를 참조하지 않아도 API 메서드의 기호를 쉽게 알아볼 수 있도록 만들어야 한다
새로운 상황을 만드는 것보다 기존에 사용한 모델과 패턴을 이용해 사용자가 익숙한 상황에 놓여 작업에 집중할 수 있도록 한다

그럼에도 문서화는 중요하고 누구나 예제 코드를 보고 어떻게 적용하면 될지 이해하게 하는 것이 좋다

## 한눈에 들어오는

- 사용자가 API를 어떻게 사용해야할 지 한눈에 이해할 수 있는 것
- 직관적이고 논리적인 객체 모델을 만드는 것
- 이름만 봐도 대략 그 기능이 짐작이 되도록 하는 것
  - 축약된 형태를 가능하면 피한다

## 잘못 사용하기도 어렵게

- 잘못된 파라미터 혹은 사용해서는 안되는 값을 파라미터로 전달하는 경우를 막는다
  - 같은 타입을 가진 여러개의 파라미터는 잘 못된 순서로 전달할 여지가 있다
    enum이나 새로운 클래스로 이용하여 컴파일러가 오류를 알릴 수 있도록 한다

## 일관성 있는

- 일관성 장점
  - 더 적은 것만을 기억하면 된다
  - 사용자가 쉽게 익숙해 진다
- 일관성을 가져야하는 것
  - 일관성 있는 명명 규칙
  - 파라미터의 순서
  - 표준 패턴
  - 의미론적 메모리 모델
  - 예외 및 오류 처리
  - 등등등

- 일관성을 가지는 법
  - 다형성을 적용한다
  - 템플릿을 이용한다

## 수직적인

- 무엇이 수직적인가?
  - 두 벡터가 수직인 것은 직각이고 내적은 0이다
  - 서로에게 영향을 미치지 않는다
  - 서로에게 영향을 미치지 않는 메서드
- 중요한 요소
  - 중복을 제거
    - 같은 정보가 두가지 이상의 방법으로 반복되지 않게 한다
  - 독립성 증가
    - 노출되는 개념에 중복된 의미가 없어야한다
    - 중첩되는 개념들은 기반 컴포넌트로 분리한다

## 견고한 자원 할당

- c++의 대부분의 버그는 잘못된 포인터나 참조를 사용하는 데서 발생한다
  - NULL 포인터 참조
  - 메모리 이중 해제
  - 유효하지 않은 메모리 접근
  - 할당자 혼용 (malloc으로 할당하고 delete로 해제하는 등)
  - 잘못된 배열 해제
  - 메모리 누수
- 해결법
  - 공유 포인터 (레퍼런스 카운트)
  - 약한 포인터
  - 범위 한정 포인터 (unique 포인터)
  - 팩토리 패턴 등으로 위와 같은 스마트 포인터로 접근을 강제한다

## 플랫폼 독립성

- #if / #ifdef와 같은 코드를 public 헤더에 포함하지 않는다
- 플랫폼별 코드가 달라지는 경우 플랫폼에 종속적인 코드는 .cpp파일 등 내부로 숨긴다

- 예로 스마트폰에 GPS를 이용한다
  모든 폰에 GPS가 있는 건 아닐거다
  이때 폰의 기종마다 #if / #define한 것을 pubilc 헤더에 포함하는 것 보다
  GPS를 가지는 지 확인하는 함수를 하나 추가하고
  내부에서 #if / #define으로 처리하는 것이 좋다



# 느슨한 연결

- 연결과 결합
  - 연결 : 각각의 컴포넌트가 다른 컴포넌트에 얼마나 의존하는지
  - 결합 : 컴포넌트의 다양한 함수들이 얼마나 논리 정연한지 또는 강하게 연관되어 있는지

하나의 컴포넌트 안의 멤버들은 연관성이 크고 각각의 컴포넌트가 독립적여 사용자가 각각의 컴포넌트를 따로따로 이해하도록 하며 분리해서 유지보수할 수 있게 한다
즉 연결을 느슨하게 결합은 강하게한다

## 이름만 연결

- 클래스 A가 클래스 B의 어떤 멤버와 크기에 대해 알필요 없고 이름만 필요한 경우
  - include 없이 전방 선언으로 물리적인 연결을 없앨 수 있다

## 클래스 연결 줄이기

- 멤버 함수 대신 비멤버, 비프렌드 함수를 이용한다

- 예시

  ```C++
  class MyObject {
  public:
      std::string GetName() const;
  private:
      std::string mName;
  };
  void PrintName(const MyObject &obj) const;
  ```

  위의 예시 코드에서 PrintName 자유 함수는 MyObject의 멤버가 아니므로 public 멤버에만 접근 가능하다 
  이로서 MyObject의 내부 코드가 변경되어도 문제가 발생할 확률이 낮아진다
  이때 MyObject와 PrintName의 개념적 관계를 위해 같은 네임스페이스 안에 선언할 수 있다

