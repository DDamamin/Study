# 패턴

Chapter02의 고품질 API를 개발하기 위한 기술과 정책에 대한 내
디자인 패턴과 C++ API 설계와 관련된 이디엄(idiom)에 대해 설명

__[디자인 패턴의 종류]__

|__생성패턴__||
| ---- | ---- |
|추상 팩토리| 연관된 팩토리 그룹을 캡슐화 한다|
|빌더|복잡한 객체의 표현 방법과 구조를 분리한다|
|팩토리 메서드|클래스의 인스턴스 생성을 서브클래스로 넘긴다|
|프로토타입|새로운 객체를 새성하기 위해 복제 가능한 클래스의 인스턴스 프로토타입을 명시한다|
|싱글톤|오직 하나의 클래스 인스턴스만 생성한다|

|__구조패턴__||
|---|---|
|어댑터|한 클래스이 인터페이스를 다른 인터페이스로 변경한다|
|브릿지|구현된 추상화를 독립적으로 변경시킬 수 있도록 분리한다|
|컴포지트|부분-전체 계층을 표현하기 위해 객체를 트리 구조로 구성한다|
|데코레이터|이미 존재하는 객체에 동적으로 행동을 추가한다|
|퍼사드|서브 시스템의 인터페이스에 일관된 고수준의 인터페이스를제 제공하다|
|플라이급|여러 가지의 작은 객체들을 효과적으로 지우너하기 위해 공유를 사용한다|
|프록시|다른 객체의 접근을 제어하기 위한 대체 방법을 제공한다|

| 행동 패턴     |                                                              |
| ------------- | ------------------------------------------------------------ |
| 책임 연쇄     | 송신 객체의 요청이 처리될 수 있도록 하나 이상의 수신 객체를 제공한다 |
| 커맨드        | 객체 형태로 요청이나 연산을 캡슐화하고 연산 취소를 지원한다  |
| 인터프리터    | 주어진 언어로 어떻게 문장들을 표현하고 평가하는지를 명시한다 |
| 이터레이터    | 객체에 저장된 여러 요소들을 순차적으로 접근할 수 있는 방법을 제공한다 |
| 메디에이터    | 객체가 어떻게 상호작용하는지를 캡슐화 하는 객체를 정의한다   |
| 메멘토        | 나중에 같은 상태로 객체가 다시 정의될 수 있도록 해당 객체의 내부 상태를 캡처한다 |
| 옵저버        | 1대 다의 객체 관계에서 상태 변경 알림을 처리한다             |
| 스테이트      | 객체의 내부 상태가 변경되면 자신의 형태를 변경하도록 허용한다 |
| 스트레티지    | 같은 계열의 알고리즘을 정의해서 각각을 캡슐화 한 후 런타임에 서로 교환 가능하도록 만든다 |
| 템플릿 메서드 | 연산의 알고지즘 뼈대를 정의하고 일부 단계는 서브클래스에서 처리하도록 넘긴다 |
| 방문자        | 객체 구조를 이루는 요소에 대해 수행할 연산을 표현한다        |

GOF의 디자인 패턴에서 디자인 패턴을 생성 패턴, 구조 패턴, 행동 패턴으로 분류하였다
이후 동시성 디자인 패턴을 비롯해 몇 종류의 디자인 패턴이 추가되었고 코어, 생성, 주변부와 그 이외 등으로 좀 더 개선된 패턴의 새로운 분류체계를 제시되었다

일반적인 디자인 패턴은 아닌 C++이디엄도 존재한다

여기서는 다음 내용을 주로 다룬다

- Pimple 이디엄
  내부의 구체적인 코드를 public 헤더로부터 완전히 숨긴다
- 싱글톤과 팩토리 메서드
  대표적인 생성 디자인 패턴이다
- 프록시, 어댑터, 퍼사드
  기존에 호환되지 않거나 오래된 인터페이스의 문제를 상위 수준에서 랩핑하여 해결하는 방법이다
  주로 잘못 설계된 코드의 인터페이스를 개선하려는 API개발에서 사용된다
- 옵저버
  행동 패턴으로 클래스간 집적적인 의존성을 제거한다
  개념적으로 관련없는 클래스끼리 서로 통신할 수 있도록 만든다



## Pimple 이디엄

pointer of implementation(구현 포인터)의 약자
주된 목적은 private으로 선언한 구체적인 코드를 외부로 노출하지 않는 것이다

### Pimple 사용

- private 멤버 변수만 포함한다
- private 멤버를 포함한다
- pulic 클래스의 모든 메서드와 대응되는 메서드를 Impl 클래스에 구현한다

제약 사항

- private 가상 메서드를 사용할 수 없다
- Impl 클래스가 public 클래스의 메서드를 호출할 수 있도록 Impl 구현 클래스(혹은 메서드)에 public 클래스를 참조하는 포인터를 보낼 수 있다

### 의미론적 복사

복사 생성자를 구현하지 않는 경우 얕은 복사가 수행되어 두 객체가 같은 Impl 객체를 참조한다 Impl 객체가 어느 한 객체에 의해 소멸시 거의 모든 상황에서 예상치 못한 오류가 발생한다

- 클래스를 복사할 수 없게 만든다
  복사 생성자를 private으로 선언한다
- 복사 기능을 명시적으로 정의한다
  깊은 복사를 하는 복사 생성자를 선언하고 정의한다

### Pimple과 스마트 포인터

Pimple은 메모리 할당과 해제가 필요해 쉽게 오류를 발생시킬 수 있다

스마트 포인터를 이용하면 이러한 문제를 쉽게 해결가능하다

### 장점

- 정보 은닉
- 의존성 제거
  시스템 의존성을 비롯한 여러 의존성을 .cpp파일로 옮길 수 있다
- 빠른 컴파일
  API의 계층 구조가 줄어들어 컴파일이 빨라지는데 Chapter07에서 더 자세히 다룬다
- 뛰어난 이진 호환성
  Pimple 이디엄을 이용해 개발한 객체의 크기는 바뀌지 않는다.
- 지연 할당
  Imple 클래스를 필요할 때 생성가능해 네트워크 연결과 같은 제한된 또는 많은 비용이 드는 리소스를 사용시 유용하다

### 단점

- 모든 객체마다 별도의 구현 객체를 메모리에 할당하고 해제해야한다

- 포인터의 크기 만큼 객체 크기가 늘어난다. 

- 모든 변수 접근에 간접 참조의 비용이 발생한다
- `mImpl ->`와 같은 접두어를 이용해 모든 private 멤버 변수에 접근해야한다

위의 단점이 있음에도 불구하고 API 사용자에게 좋은 코드를 제공하길 원한다면 사용할만 하다

성능 문제는 '빠른 Pimpl'이디엄(Sutter, 1999)를 확인하자



## 싱글톤

오직 하나의 인스턴스만 생성한다



























