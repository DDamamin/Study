# Clean Code #6 #

### 객체와 자료 구조

<table>
    <tr> 
    	<td></td>
        <td>객체</td>
        <td>자료 구조</td>
    </tr>
    <tr> 
    	<td>정의</td>
        <td>멤버 변수 등의 세부 사항을 외부에 노출하지 않고 추상화해 제공한다</td>
        <td>멤버 변수를 단순하게 노출시켜 제공한다 (단순 get, set 프로퍼티도 여기에 속한다)</td>
    </tr>
    <tr> 
    	<td>정의 예시</td>
        <td>'탈 것'이라는 클래스에서 남은 연료량을 백분율로 추상화해 제공</td>
        <td>'탈 것'이라는 클래스에서 남은 연료량을 변수 값 그대로 제공</td>
    </tr>
    <tr>
    	<td>영향</td>
        <td>하나의 객체는 그 기능이 추가되거나 변경되면 각 객체가 변경되어야 한다</td>
        <td>단순한 자료 구조들이 있고 이를 동작시키는 클래스를 따로 두면 동작이 추가되거나 변경되도 자료 구조는 변하지 않는다</td>
    </tr>
    <tr>
    	<td rowspan="2">영향 예시</td>
        <td colspan="2">상황. 여러 도형들이 있고 각 도형의 넓이를 구한다</td>
    </tr>
    <tr>
        <td>Shape 인터페이스를 만들고 circle, rectangle 등으로 구현한다. 이때 Shape 인터페이스에 넓이 외에도 다른 기능이 추가되면 circle, rectangle 모두 변경해야 한다.</td>
        <td>circle, rectangle 자료 구조가 있고 각각의 요소 (반지름, 가로, 세로 길이 등)를 노출한다. Geometry 클래스에서 area 메서드로 각 도형을 받아 계산한다. 이 경우 다른 기능이 추가된다면 자료 구조의 변경은 없지만 Geometry의 변경이 크다. -> OCP를 위반한다.</td>
    </tr>
</table>

위의 표는 객체와 자료 구조의 구분과 차이점이다. 경우에 따라 두가지를 적절히 사용해야한다

디미터 법칙
객체는 외부에서 세부 사항을 알게 해선 안된다.
즉 객체의 어떤 메소드가 멤버 변수를 그대로 리턴해서 사용하도록 하면 안된다.
`ctxt.getOptions().getScratchDir().getAsolutePath();` 이렇게 있다면 잘 못된 것이다.
ctxt의 내부 인스턴스를 가지고 그 인스턴스의 내부 인스턴스에 또 다시 접근하고 있다.

이 경우 ctxt를 자료 구조로 변경하거나 위의 구절의 목적을 찾아 메서드를 새로 만드는 것이 좋다.
단 자료 구조로 변경하는 건 프레임워크, 라이브러리 등에서 지원하지 않아 힘들 수 있다.

올바른 객체로 변경하려면 다음과 같이 하면된다.
위의 코드는 clean code에서 말하길 아파치에 나오는 코드라 하는데 임시 파일를 생성하기 위해 이름 경로를 얻는 코드라 한다. 따라서 이에 대한 코드는 다음과 같이 변경될 필요가 있다.
`ctxt.craeteScratchFileStream(className);` 이렇게 하면 의미도 분명하고 디미터 법칙도 지킬 수 있다.

이러한 디미터 법칙을 지켜야하는 이유는 객체의 내부가 변경되었을 때 외부의 변경을 최소화하기 위함이다. 만약 애매한 get/set으로 자료 구조도 객체도 아닌 잡종이 되었을 때 내부 구조가 변경된다면 관련 코드를 모두 찾아 변경해야할 수 있다.