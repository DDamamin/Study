# JavaScript의 메모리 관리

보편적인 프로그래밍에서 메모리를 사용하는데 있어서 다음의 과정을 거친다

1. 필요할때 할당
2. 사용(읽기, 쓰기, ~~듣기 말하기~~)
3. 필요없어지면 해제

C언어 같은 저수준 언어는 1번과 3번을 개발자가 직접 명시적으로 작성해야 한다
그렇지만 Javascript같은 고수준 언어는 GC(가비지 콜렉터) 등의 방법으로 암시적으로 해준다

### 할당

javascript는 어느 프로그래밍 언어나 다름 없이 스택과 힙 구조를 가진다
원시타입을 할당시에는 스택에 할당이 된다

원시타입 6가지

- Boolean

- [Boolean](https://developer.mozilla.org/ko/docs/Glossary/불린)
- Null
- Undefined
- Number
- String
- Symbol(ECMAScript 6 에 추가됨)

이외의 배열을 비롯한 객체들은 힙에 저장되어 관리된다



### 사용

메모리를 관리하는데 있어서 메모리를 사용할 때 알아야할 것이 있습니다

__원시타입은 한 번 값이 정해지면 바뀌지 않습니다__

```javascript
let a = 1;
let b = a;
```

javascript가 원시타입에 있어서 call by value로 알려져 있습니다
그러므로 위의 코드에서 a와 b는 각자 다른 1이라는 값을 가진 공간을 가질 거라 추측할 수 있습니다

하지만 실제로는 a와 b 모두 같은 공간을 가집니다
그럼에도 불구하고 a의 값을 변경하면 b의 값이 바뀌지 않습니다
이는 원시타입의 값을 바꾸고자 하면 바뀐 후의 값을 가지는 새로운 공간을 할당하기 때문입니다

``` javascript
let a = 1; //이때 a가 가지는 공간의 주소를 0x01이라고 합시다
let b = a; //b가 가지는 공간의 주소는 0x01입니다
a = a + 1; //이제 a가 가지는 공간의 주소는 0x02(혹은 다른 곳) 입니다
```

그러므로 위의 코드를 실행해도 b는 여전히 1을 가지고
javascript가 사실은 call by value는 아니지만 call by value처럼 동작합니다



__const는 주소를 바꾸는 것을 허용하지 않습니다__

const는 값을 바꾸지 않는다고 생각할 수 있습니다
이러한 생각은 const로 배열을 저장할 때 배열의 원소를 바꿀 수 있는데서 초보자에게 혼란을 야기합니다

이러한 일이 일어나는 이유는 const는 값아니라 정확히는 주소를 못 바꾸게 합니다

```javascript
const a = 1;
a = a + 1; //a의 주소가 바뀌여야 하므로 이는 에러가 발생합니다
```

위에서 설명했듯 원시타입을 변경하는 것은 새로운 주소를 만들어내므로 const로 지정된 a에 저장하려 할때 에러가 발생합니다

```javascript
const a = [];
a.push(5);
```

위의 코드는 에러가 발생하지 않는데 이는 다음과 같습니다

힙에 배열을 위한 공간하나를 마련합니다
a는 이를 참조합니다

배열에 요소를 추가하거나 변경해도 배열의 주소는 그대로 이므로 a가 가지는 공간의 주소역시 그대로 입니다

따라서 이러한 코드는 에러를 발생하지 않습니다

단 아래의 코드는 에러를 발생시킵니다

```javascript
const a = [5,5];
a = [];
```

이는 a에 새로운 배열을 만들어서(새로운 주소를 참조시킬려해서) 에러를 발생시킵니다



### 해제

javascript에서 메모리 해제는 GC를 통해 암시적으로 이루어 집니다



__참조__
javascript 엔진은 GC를 구현하기 위해 참조를 가장 참조란 A라는 오베젝트(메모리)에서 B라는 오브젝트(메모리)로 접근할 수 있다면 'B는 A에 참조된다'라고 합니다 이때 오브젝트는 javascript의 오브젝트 뿐만 아니라 함수의 스코프까지 포괄합니다

__참조 세기__
GC를 구현하는 방법에는 여러가지 방법이 있는데 javascript에서는 특히 예전 javascript 엔진은 참조 세기 방식을 사용합니다 이는 c++의 스마트 포인터, shared_ptr과 비슷하게 동작하는데 어떤 오브젝트를 참조하는 오브젝트가 없으면 더 이상 사용하지 않는다고 판단하고 해제합니다

GC를 구현하는 방법에는 여러가지 방법이 있는데 javascript에서는 특히 예전 javascript 엔진은 참조 세기 방식을 사용합니다 이는 c++의 스마트 포인터, shared_ptr과 비슷하게 동작하는데 어떤 오브젝트를 참조하는 오브젝트가 없으면 더 이상 사용하지 않는다고 판단하고 해제한다

참조의 예로 모든 javascript의 오브젝트는 prototype을 암시적으로 참조하고 속성은 명시적으로 참조합니다 (prototype과 속성 모두 오브젝트에서 접근할 수 있기 때문이다)

한 마디로 어디에서도 접근 불가능한 객체는 해제됩니다

__참조 세기 문제점 : 순환 참조__

```javascript
function f(){
	let o = {};
	let o2 = {};
	o.a = o2;
	o2.a = o;
}
```

위와 같은 경우는 o는 o2를 참조하고 그와 동시에 o2는 o를 참조합니다

이런 경우에 이 둘은 함수 f의 함수 호출이 끝나 스코프를 벗어나더라도 두 객체의 참조는 여전히 남아 있으므로 GC의 대상이 되지않아 해제가 되지 않습니다
이런 경우 메모리 누수로 이여집니다

__Mark-and-sweep 방식__
이러한 순환 참조의 문제점을 해결하기 위해 최신 javascript 엔진은 다른 방식을 사용하여 GC를 구현합니다

이는 모든 오브젝트의 집합인 roots를 가집니다 (정확히는 전역 변수의 집합)
roots에서 참조하는 오브젝트로 다시 그 오브젝트에서 참조하는 오브젝트로 탐색하여 닿을 수 있는 오브젝트와 그렇지 못하는 오브젝트로 구분합니다
그런 후 닿을 수 없는 오브젝트를 해제하면 됩니다
이러한 방식이면 순환 참조한고 있는 오브젝트도 그 외부에서 참조하고 있지 않아 닿을 수 없다면 해제되게 됩니다