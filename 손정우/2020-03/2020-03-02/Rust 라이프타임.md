# Rust 라이프타임

Rust에는 라이프타임이라는 보통의 다른 언어에는 없는 문법이 있습니다

이는 유효하지 않은 댕글링 참조를 막아 줍니다



### 댕글링 참조

우리가 프로그래밍을 하다보면 주소 자체가 유효하지 않은 공간을 참조할 때가 있습니다
이러한 참조를 댕글링 참조라 합니다 C++에서 간단하게 구현하면 다음과 같습니다

```C++
int main(){
    int *a = new int(5);
    
    delete a;
    
    (*a)++;//유효하지 않은 주소를 참조
    
    return 0;
}
```

이렇게 유효하지 않은 주소를 참조하는 경우 프로그램에 치명적인 결함을 가져옵니다
따라서 이러한 것들을 주의하며 코드를 작성해야합니다

하지만 Rust에서는 이러한 코드를 컴파일 단계에서 찾아내 컴파일 실패로 만들어줍니다
이런 것이 가능하도록 라이프타입이라는 개념을 사용합니다



### 라이프타임

라이프타임은 쉽게 말해 해당 객체가 어디까지 유효한지 표시하는 것입니다

```Rust
{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &x;    //  |     |
    }              // -+     |
                   //        |
    println!("r: {}", r); // |
                   //        |
                   // -------+
}
```

위와 같은 Rust코드가 있을 때 변수 r의 라이프타임을 `'a`라하고 변수 x의 라이프타임을 `'b`라 이름 지었습니다

하지만 여기까지는 당연한 것이며 큰 필요가 느껴지지 않습니다



### 함수에서의 제네릭 라이프타임

```Rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

위의 코드는 두 문자열을 받아 더 큰 문자열을 반환하는 함수입니다

별 문제 없어 보이는 이 코드는 컴파일이 되지 않습니다
현재는 파라미터로 들어온 참조 x, y를 반환하지만 잠재적으로 함수 내부에서 생성된 문자열의 참조를 반환할 가능성이있습니다

함수 내부에서 생성되면 함수가 끝나면 drop되게 됩니다

이런 이유로 위의 코드는 위험합니다
반환되는 참조가 함수보다 라이프타임이 길어야 함이 보장될 수 있도록 명시해야합니다

```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

위의 코드는 라이프타임을 명시했습니다

제네릭 문법으로 명시할 라이프타임을 지정합니다
파라미터 x와 y그리고 반환되는 것이 같은 라이프타임인 'a을 가집니다
이는 반환되는 것이 적어도 외부에서 오는(함수 보다 라이프타임이 긴) 파라미터 x, y의 라이프타임 만큼은 되어야 함을 알립니다

이렇게 라이프타임을 명시해서 우리의 코드는 더욱 안전해 졌습니다

이제 함수 내부에서 생성된 것을 반환하려할 시 컴파일러가 혼냅니다

