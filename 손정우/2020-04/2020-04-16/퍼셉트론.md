# 퍼셉트론

퍼셉트론은 뉴런을 흉내낸다

입력된 값들은 각 가중치가 곱해지고 난 후 모두 더해진다
모두 더한 값이 어떤 임계치를 넘는 다면 1을 그렇지 않다면 0을 리턴한다
여기까지가 하나의 퍼셉트론이다

하나의 퍼셉트론을 하나의 논리 소자로 볼 수 있으며 이 경우 가중치는 저항과 역할이 같을 것이다
이점을 이용해 실제로 퍼셉트론으로 AND, NAND, OR 게이트를 구현할 수 있다

```python
import numpy as np


def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([1.0, 1.0])
    b = -1.0
    return (np.sum(x * w) + b) > 0


def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])
    b = 0.7
    return (np.sum(x * w) + b) > 0


def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.2
    return (np.sum(x * w) + b) > 0
```

위의 코드에서 임계치가 b(asis), 편향로 바뀌었다
이는 x * w > b에서 x * w - b > 0로 b가 이항되었을 뿐이다
0보다 큰지 작은지만 확인하도록 만들기 위함이다

이렇게 AND, NAND, OR 게이트를 구현할 수 있는데 XOR 게이트는 생각을 좀 더 해야한다

[XOR 게이트 진리표]

| x1   | x2   | y    |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 1    | 0    | 1    |
| 0    | 1    | 1    |
| 1    | 1    | 0    |

여기서 퍼셉트론을 수식으로 나타내면 다음과 같다
x1 *w1 + x2 * w2 - b > 0
그런데 이 경우 조금만 생각하면 이러한 수식에서는 XOR 게이트를 만들기에는 부족하다는 것을 알 수 있다
즉 수식이 더 복잡해야함을 의미하는데 이 말은 다시 하나의 퍼셉트론으로는 부족하다는 말이다
이는 논리 소자 XOR를 만들 때도 마찬가지인데 그래서 사람들은 다른 게이트를 합성하는 것으로 해결했다

입력값이 NAND, OR게이트를 거친 후 그 둘을 AND한다

```python
def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y
```

이렇게 단일 퍼셉트론을 연결해 더 복잡한 일을 가능하게 한다

이를 좀 더 확장해 입력층, 은닉층, 출력층을 가지고 가중치, 편향을 자동으로 학습을 한다면 바로 신경망이 된다
