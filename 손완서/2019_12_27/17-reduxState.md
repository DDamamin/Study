# React 17. 리덕스를 사용하여 리액트 애플리케이션 상태 관리하기

리액트 애플리케이션에 리덕스를 사용하면, 상태 업데이트에 관한 로직을 모듈로 따로 분리하여 컴포넌트 파일과 별개로 관리 가능하므로 코드를 유지 보수하는데 도움됨
또한, 여러 컴포넌트에서 동일한 상태를 공유해야 할 때 매우 유용하며, 실제 업데이트가 필요한 컴포넌트만 리렌더링되도록 쉽게 최적화해 줄 수도 있음
리액트 애플리케이션에서 리덕스를 사용할 때는 store 인스턴스를 직접 사용하기보다는 주로 react-redux라는 라이브러리에서 제공하는 유틸 함수(connect)와 컴포넌트(Provider)를 사용하여 리덕스 관련 작업을 처리함

## 1. UI 준비하기

리액트 프로젝트에서 리덕스를 사용할 때 가장 많이 사용하는 패턴은 프레젠테이셔널 컴포넌트와 컨테이너 컴포넌트를 분리하는 것
프레젠테이셔널 컴포넌트 : 상태 관리가 이루어지지 않고, 그저 props를 받아 와서 화면에 UI를 보여 주기만 하는 컴포넌트를 말함
컨테이너 컴포넌트 : 리덕스와 연동되어 있는 컴포넌트로, 리덕스로부터 상태를 받아 오기도 하고 리덕스 스토어에 액션을 디스패치하기도 함

## 2. 리덕스 관련 코드 작성하기

actions, constants, reducers라는 세 개의 디렉터리를 만들고 그 안에 기능별로 파일을 하나씩 만드는 방식
코드를 종류에 따라 다른 파일에 작성하여 정리할 수 있어서 편리하지만, 새로운 액션을 만들 때마다 세 종류의 파일을 모두 수정해야 하기 때문에 불편하기도 함

액션 타입, 액션 생성 함수, 리듀서 함수를 기능별로 파일 하나에 몰아서 다 작성하는 방식 : Ducks 패턴
Ducks 패턴을 사용하여 액션 타입, 액션 생성 함수, 리듀서를 작성한 코드 : 모듈

가장 먼저 해야 할 작업은 액션 타입을 정의하는 것
액션 타입은 대문자로 정의하고, 문자열 내용은 '모듈 이름/액션 이름'과 같은 형태
문자열 안에 모듈 이름을 넣음으로써, 나중에 프로젝트가 커졌을 때 액션의 이름이 충돌되지 않게 해줌

앞부분에 export 키워드를 추가함으로써 추후 이 함수를 다른 파일에서 불러와 사용 가능

export와 export default의 차이는 export는 여러 개를 내보낼 수 있지만 export default는 단 한 개만 내보낼 수 있다는 것

액션 생성 함수에서 전달받은 파라미터는 액션 객체 안에 추가 필드로 들어가게 됨

액션 생성 함수 중에서 insert 함수는 액션 객체를 만들 때 파라미터 외에 사전에 이미 선언되어 있는 id라는 값에도 의존
이 액션 생성 함수는 호출될 때마다 id값에 1씩 더해 줌
이 id 값은 각 todo 개개체가 들고 있게 될 고윳값

스토어를 만들 때는 리듀서를 하나만 사용해야 함

## 3. 리액트 애플리케이션에 리덕스 적용하기

- 1. 스토어 만들기

- 2. Provider 컴포넌트를 사용하여 프로젝트에 리덕스 적용하기
     리액트 컴포넌트에서 스토어를 사용할 수 있도록 App 컴포너트를 react-redux에서 제공하는 Provider 컴포넌트로 감싸 줌
     이 컴포넌트를 사용할 때는 store를 props로 전달해 주어야 함

- 3. Redux DevTools의 설치 및 적용
     Redux DevTools는 리덕스 개발자 도구이며, 크롬 확장 프로그램으로 설치하여 사용 가능
     패키지를 설치하여 적용하면 코드가 훨씬 깔끔해짐

## 4. 컨테이너 컴포넌트 만들기

리덕스 스토어와 연동된 컴포넌트를 컨테이너 컴포넌트라고 부름

컴포넌트를 리덕스와 연동하려면 react-redux에서 제공하는 connect 함수를 사용해야 함

connect(mapStateToProps, mapDispatchToProps)(연동할 컴포넌트)
여기서 mapStateToProps는 리덕스 스토어 안의 상태를 컴포넌트의 props로 넘겨주기 위해 설정하는 함수
mapDispatchToProps는 액션 생성 함수를 컴포넌트의 props로 넘겨주기 위해 사용하는 함수

connect 함수를 호출하고 나면 또 다른 함수를 반환
반환된 함수에 컴포넌트를 파라미터로 넣어 주면 리덕스와 연동된 컴포넌트가 만들어짐

위 코드를 더 쉽게 풀면 다음과 같은 형태
const makeContainer = connect(mapStateToProps, mapDispatchToProps)
makeContainer(타깃 컴포넌트)

mapStateToProps와 mapDispatchToProps에서 반환하는 객체 내부의 값들은 컴포넌트의 props로 전달됨
mapStateToProps는 state를 파라미터로 받아 오며, 이 값은 현재 스토어가 지니고 있는 상태를 가리킴
mapDispatchToProps의 경우 store의 내장 함수 dispatch를 파라미터로 받아옴

connect 함수를 사용할 때는 일반적으로 mapStateToProps와 mapDispatchToProps를 미리 선언해 놓고 사용

컴포넌트에서 액션을 디스패치하기 위해 각 액션 생성 함수를 호출하고 dispatch로 감싸는 작업이 번거로울 수 있음
이와 같은 경우에는 리덕스에서 제공하는 bindActionCreators 유틸 함수를 사용하면 간편

더 편한 방법은 mapDispatchToProps에 해당하는 파라미터를 함수 형태가 아닌 액션 생성 함수로 이루어진 객체 형태로 전달
두 번째 파라미터를 객체 형태로 전달하면 connect 함수가 내부적으로 bindActionCreators 작업을 대신 해줌

## 5. 리덕스 더 편하게 사용하기

액션 생성 함수, 리듀서를 작성할 때 redux-actions라는 라이브러리와 immer 라이브러리를 활용하면 리덕스를 훨씬 편하게 사용 가능

1. redux-actions

redux-actions를 사용하면 액션 생성 함수를 더 짧은 코드로 작성 가능
리듀서 작성할 때 switch/case 문이 아닌 handleActions라는 함수를 사용하여 각 액션마다 업데이트 함수를 설정하는 형식으로 작성 가능

handleActions 함수의 첫 번째 파라미터에는 각 액션에 대한 업데이트 함수를 넣어 주고, 두 번째 파라미터에는 초기 상태를 넣어 줌

createAction으로 액션을 만들면 액션에 필요한 추가 데이터는 payload라는 이름을 사용
액션 생성 함수에서 받아 온 파라미터를 그대로 payload에 넣는 것이 아니라 변형을 주어서 넣고 싶다면, createAction의 두 번째 함수에 payload를 정의하는 함수를 따로 선언해서 넣어 줌

2. immer

객체의 깊이가 깊지 않을수록 추후 불변성을 지켜 가면서 값을 업데이트할 때 수월
하지만 상황에 따라 상태 값들을 하나의 객체 안에 묶어서 넣는 것이코드의 가독성을 높이는 데 유리하며, 나중에 컴포넌트에 리덕스를 연동할 때도 더욱 편리

객체의 구조가 복잡해지거나 객체로 이루어진 배열을 다룰 경우, immer를 사용하면 훨씬 편리하게 상태 관리 가능
일반 자바스크립트로 처리하는 것이더 편할 때는 immer를 적용하지 않아도 됨

## 6. Hooks를 사용하여 컨테이너 컴포넌트 만들기

리덕스 스토어와 연동된 컨테이너 컴포넌트를 만들 때 connect 함수를 사용하는 대신 react-redux에서 제공하는 Hooks 사용 가능

1. useSelector로 상태 조회하기

useSelector Hook을 사용하면 connect 함수를 사용하지 않고도 리덕스의 상태를 조회할 수 있음
사용법) const 결과 = useSelector(상태 선택 함수);

여기서 상태 선택 함수는 mapStateToProps와 형태가 똑같음

2. useDispatch를 사용하여 액션 디스패치하기

useDispatch라는 Hook은 컴포넌트 내부에서 스토어의 내장 함수 dispatch를 사용할 수 있게 해줌
컨테이너 컴포넌트에서 액션을 디스패치해야 한다면 이 Hook 사용
사용법) const dispatch = useDispatch();
dispatch({ type: 'SAMPLE_ACTION' });

만약 컴포넌트 성능을 최적화해야 하는 상황이 온다면 useCallback으로 액션을 디스패치하는 함수를 감싸 주는 것이 좋음

3. useStore를 사용하여 리덕스 스토어 사용하기

useStore Hooks를 사용하면 컴포넌트 내부에서 리덕스 스토어 객체를 직접 사용할 수 있음
사용법) const store = useStore();
store.dispatch({ type: 'SAMPLE_ACTION' });
store.getState();

useStore는 컴포넌트에서 정말 어쩌다가 스토어에 직접 접근해야 하는 상황에만 사용해야 함

4. TodosContainer를 Hooks로 전환하기

connect 함수 대신에 useSelector와 useDispatch Hooks를 사용하는 형태로 전환

5. useActions 유틸 Hook을 만들어서 사용하기

useActions를 사용하면, 여러 개의 액션을 사용해야 하는 경우 코드를 훨씬 깔끔하게 정리하여 작성 가능
useActions Hook은 액션 생성 함수를 액션을 디스패치하는 함수로 변환
액션 생성 함수를 사용하여 액션 객체를 만들고, 이를 스토어에 디스패치하는 작업을 해 주는 함수를 자동으로 생성
첫 번째 파라미터는 액션 생성 함수로 이루어진 배열
두 번째 파라미터는 deps 배열, 이 배열 안에 들어 있는 원소가 바뀌면 액션을 디스패치하는 함수를 새로 만듦

6. connect 함수와의 주요 차이점

connect 함수를 사용하여 컨테이너 컴포넌트를 만들었을 경우, 해당 컨테이너 컴포넌트의 부모 컴포넌트가 리렌더링될 때 해당 컨테이너 컴포넌트의 props가 바뀌지 않았다면 리렌더링이 자동으로 방지되어 성능 최적화
useSelector를 사용하여 리덕스 상태를 조회한 경우 이 최적화 작업 X
이런 경우 성능 최적화를 위하여 React.memo를 컨테이너 컴포넌트에 사용해 주어야 함
