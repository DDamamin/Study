# Windows API 정복 1권(김상형 저) 정리 17편

**저작권 문제시 연락주시면 바로 처리하도록 하겠습니다. 학생으로서 독서를 읽은 뒤 정리하면서 학습하는 용도로만 사용하였습니다. 양해 부탁드립니다.**

## 무효영역

InvalidateRect 함수를 호출하여 강제로 WM_PAINT 메시지를 발생시켰다.  
WM_PAINT 메시지는 윈도우가 다시 그려져야 할 필요가 있을 때마다 호출되는데 다시 그려져야 할 필요가 있다는 말은 무효영역(Invalid Region)이 있다는 뜻이다.  
그렇다면 무효하다는 말이 과연 무슨 의미인지 알아보기 위해 다음 경우를 보자.  
계산기 프로그램과 메모장 프로그램이 겹쳐져 있으며 계산기 프로그램의 화면 영역 일부가 메모장에 의해 가려져 있다.  
  
이 상태에서 메모장이 자리를 옮겨 계산기의 가려졌던 부분이 드러나면 이 부분이 바로 무효영역이 된다.  
즉 무효하다는 말은 원래 그려져야 할 모습과 다른 모습을 가지고 있다는 뜻이며 곧 다시 그릴 필요가 있다는 의미이다.  
메모장이 가리고 있던 계산기의 영역에는 원래 버튼들이 그려져 있어야 하나 그렇지 못하므로 무효한 것이다.  
운영체제는 윈도우가 무효영역을 가지고 있으면 이 윈도우에게 WM_PAINT 메시지를 보내 다시 그리게 한다.  
  
WM_PAINT 메시지를 받아 다시 그리면 무효영역은 없어지고 계산기의 전 영역이 유효영역이 되며 더 이상 윈도우를 다시 그려야 할 필요가 없어진다.  
물론 이 상태에서 다시 윈도우의 일부분이 가려졌다 나타나거나 최소화되었다가 복구되면 무효영역이 발생하고 그때마다 WM_PAINT 메시지를 받게 된다.  
  
이런 식으로 운영체제는 윈도우의 일부가 지워졌을 때 지워진 작업영역을 무효로 만들어 윈도우가 다시 그려지도록 한다.  
직접 복구하지 않는 대신 철저하게 신호를 보내 스스로 그리기를 할 수 있도록 도움을 주는 것이다.  
그러나 내부적인 변화에 의해 화면이 다시 그려져야 할 때는 운영체제가 작업영역을 무효화하지 않는다.  
왜냐하면 입력받은 문자를 화면으로 출력할 것인지, 내부적인 계산에만 사용할 것인지 네트워크나 DB로 전송할 것인지 운영체제가 판단할 수 없기 때문이다.  
그래서 프로그램의 내부에서 윈도우의 모습을 변경시켰을 때는 변경된 부분을 다시 그리도록 강제로 무효화해야 하며 이때 사용되는 함수가 바로 InvalidateRect이다.  
  
    BOOL InvalidateRect(HWND hWnd, CONST RECT* lpRect, BOOL bErase);

이 함수는 윈도우의 작업영역을 무효화하여 운영체제로 하여금 WM_PAINT 메시지를 해당 윈도우로 보내도록 한다.  
첫 번째 인수 hWnd는 무효화의 대상이 되는 윈도우, 즉 다시 그려져야 할 윈도우의 핸들이다.  
자기 자신을 무효화 할 때는 WndProc으로 전달되는 첫 번째 인수 hWnd를 그대로 써주면 된다.  
물론 다른 윈도우를 지정하면 자신이 아닌 다른 윈도우를 무효화할 수도 있다.  
  
두 번째 인수 lpRect는 무효화할 사각영역을 지정하되 이 값이 NULL이면 윈도우의 전 영역이 무효화된다.  
전 영역을 무효화하면 완전히 다시 그리므로 확실하게 그려지기는 하겠지만 그만큼 그리는 속도는 느려질 것이다.  
속도를 최대한 높이려면 변경된 최소한의 영역만을 계산하여 꼭 필요한 부분만 무효화하는 것이 좋다.  
예제에서는 전 영역을 무효화하여 모두 다시 그리도록 하였는데 예제 자체가 간단하기 때문에 속도의 저하는 느낄 수 없지만 그리 썩 좋은 방법은 아니다.  
  
세 번째 인수 bErase는 무효화되기 전에 배경을 모두 지운 후 다시 그릴 것인지 아니면 배경을 지우지 않고 그릴 것인지를 지정한다.  
이 값이 TRUE이면 배경을 지운 후 다시 그리고 FALSE이면 배경을 지우지 않은 채로 다시 그린다.  
  
예제의 경우 문자열이 계속 늘어만 나고 지워져야 할 문자가 없기 때문에 이 인수를 FALSE로 지정하였지만 지워져야 할 부분이 있다면 이 인수는 TRUE가 되어야 한다.  
예제를 다음과 같이 변경해 보자.  
  
    case WM_CHAR:
	    if ((TCHAR)wParam == ' ')
	    	str[0] = 0;
	    else
	    {
	    	len = lstrlen(str);
	    	str[len] = (TCHAR)wParam;
	    	str[len + 1] = 0;
	    }
	    InvalidateRect(hWnd, NULL, TRUE);
	    return 0;

WM_CHAR 메시지에서 wParam을 조사해 보고 스페이스 키(32)가 입력되었을 경우 문자열을 지우도록 하였다.  
이렇게 되면 기존에 출력되어 있던 문자들이 지워져야 하므로 InvalidateRect의 세 번째 인수는 TRUE가 되어야 한다.  
왜 그런지를 좀 더 자세히 알고 싶으면 이 인수를 FALSE로 바꾼 후 실행해 보아라.  
스페이스를 치면 메모리상의 문자열은 지워지지만 화면은 전혀 지워지지 않고 기존 문자열 위에 새 문자열이 덮여서 출력되는 꼴사나운 현상이 발생할 것이다.  
원래 코드의 bErase가 FALSE인 이유는 문자열이 계속 늘어나기만 하며 줄어들지 않아 새 문자열로 완전히 덮어쓸 수 있었기 때문이다.  
  
무효화 영역과 InvalidateRect 함수의 역할에 대해 좀 더 연구해 보고 싶으면 이 함수 호출문을 주석으로 묶어 제거한 후 다시 실행해 보자.  
그러면 아무리 키보드를 두드려도 문자가 화면으로 출력되지 않을 것이다.  
WM_CHAR에서 입력된 키값을 아무리 str 배열에 모아 놓아도 WM_PAINT 메시지가 전혀 발생하지 않기 때문이다.  
내부의 정보는 바뀌었지만 이 정보가 화면에 반영되지 않는다.  
이 상태에서 윈도우를 다른 윈도우로 살짝 가렸다가 다시 드러나도록 해 보면 문자들이 보이게 된다.  
다른 윈도우에 의해 가려졌다 드러남으로써 작업영역이 무효화되었으며 이때서야 비로소 WM_PAINT 메시지가 보내지기 때문이다.  
이런 동작을 강제로 해 주는 함수가 바로 InvalidateRect라고 할 수 있다.  
  
---  
  
예제에서 문자열을 입력받아 저장하는 str 버퍼는 256의 길이로 선언되었으므로 최대 255자가지의 문자열을 저장할 수 있고 255자 이상을 입력하면 메모리의 뒤쪽이 파괴되므로 이후의 프로그램 동작이 어떻게 될지는 알 수 없다.  
그러나 Visual C++ 컴파일러는 static 영역에 약간의 여유분을 두기 때문에 255자를 넘더라도 당장의 이상은 발생하지 않는다.  
심지어 str의 길이를 1로 지정한 후 실행해도 별 이상이 없다.  
그러나 이는 str 뒤쪽에 별로 중요하지 않은 정보가 있어서 우연히 잘 실행되는 것일 뿐이지 절대로 정상적인 코드는 아니다.  
컴파일러가 바뀌거나 빌드 모드가 바뀌면 언제 오작동할 지 모른다.