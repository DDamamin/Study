# Windows API 정복 1 정리 2편

## 먼저 알아야 할 것들

이제 다음 장부터 다소 복잡한 프로그래밍으로 바로 들어가게 되는데 어렵다기보다는 양이 많기 때문에 다소 혼란스러워질 것이다.  
그 전에 여기서는 몸을 푸는 기분으로 미리 알아두면 좋을 만한 내용들을 소개한다.  
어렵지 않은 내용이므로 본격적으로 헷갈리기 전에 먼저 읽고 정리해 두자.

## 변수 명명법

Windows에서는 워낙 많은 변수가 사용되므로 대체로 변수 이름을 길게 쓰며 되도록 보기 좋게(= 읽기 쉽게) 하기 위해 대문자와 소문자를 적당히 혼합하여 사용한다.  
사용하기는 변수가 많으므로 지나치게 단축형으로 쓰면 혼란스럽고 그렇다고 너무 길게 쓰면 입력하기 불편하므로 적당히 절충하여 변수 이름을 정한다.  
특히 자주 사용하는 변수 형식에 대해서는 관습적으로 정해진 접두어를 많이 사용한다.  
다음은 Windows 프로그래밍에서 주로 사용되는 접두어들이며 외워두면 여러 모로 편리하다.  
  
- cb(Count of Bytes) : 바이트 수
- dw(double word) : 부호없는 long형 정수
- h(handle) : 윈도우, 비트맵, 파일 등의 핸들
- sz(Null Teminated) : NULL 종료 문자열
- a(Array) : 배열
- w(Word) : 부호없는 정수형
- i(Integer) : 정수형
- p, lp(long pointer) : 포인터형
- b(Bool) : 논리형
  
표준 함수들은 모두 이 방식대로 인수 이름을 작성하므로 접두어들을 정확하게 외우고 있어야 함수의 인수가 어던 의미인가를 금방 파악할 수 있다.  
암기하기도 편하게 되어 있는데 예를 들어 cbString이면 문자열의 바이트 수를 나타내는 정수형 인수(또는 변수)라는 것을 쉽게 알 수 있으며 szMessage라면 널 문자열을 가리키는 포인터라는 것을 쉽게 유추해 낼 수 있다.  
  
Windows 프로그래밍에서 쓰이던 이런 변수 명명법을 헝가리식 명명법(Hungarian Naming)이라고도 하는데 이건 어디까지나 이렇게 쓰면 편하다는 것이지 꼭 지켜야 하는 의무사항은 아니다.  
더구나 이 방법은 변수의 타입에 대한 정보가 이름에 포함되어 있어 타입을 수정할 때 변수의 이름까지 같이 바꿔야 하는 불편함도 있어 요즘은 잘 사용되지 않는다.  
하지만 문서를 읽을 때는 변수 이름만으로도 타입을 쉽게 판별할 수 있어 많은 도움이 된다.  
  
변수명을 나타내는 이런 관습 외에도 Windows에서는 사용자 정의 데이터형들이 많이 있다.  
이 데이터형은 windows.h라는 헤더 파일에 typedef로 선언되어 있으며 마치 표준 데이터형처럼 사용하므로 알아두면 유용하다.  
  
- BYTE : unsigned char형
- CHAR : char형
- WORD : unsigned int형
- DWORD : unsigned long형
- LONG : long과 동일
- BOOL : 정수형이며, TRUE, FALSE 중 한 값을 갖는다.
  
기존 데이터형으로 조합이 가능한 형을 새로운 데이터형으로 정의하여 사용하는 이유는 단순히 편하게 사용하지는 의도만 있는 것은 아니다.  
Windows가 항상 인텔 기반의 IBM 컴퓨터에서만 실행되라는 법은 없으며 언젠가는 다른 시스템으로 이식될 가능성도 있는데 그럴 경우 소스 차원의 이식성을 확보하기 위해 이런 데이터형을 사용한다.  
알기 쉽게 예를 든다면 WORD형이 현재는 2바이트의 부호없는 정수형이지만 팬티엄 이후 986이나 1286쯤에는 4바이트로 확장될지도 모른다.  
또한 유니코드 환경에서는 문자형의 크기가 달라질 수도 있고 64비트나 128비트 환경에서 정수형의 길이가 바뀔 수도 있다.  
  
설사 그렇더라도 소스는 수정할 필요없이 헤더 파일에서 WORD형의 타입 정의만 바꾸고 소스를 다시 컴파일하면 이식성에 문제가 없다.  
중간 타입을 일부러 정의해서 사용하는 이유는 이식성과 호환성 확보를 위해서이므로 특별한 이유가 없는 한 unsigned short 같은 C 타입을 쓰는 것보다 WORD같은 중간 타입을 사용하는 것이 유리하다.  
단, int는 UINT라는 중간 타입이 있기는 하지만 C언어 자체에서 플랫폼에 종속적인 타입으로 정의하므로 그냥 사용해도 무방하다.

## 핸들에 대한 이해

핸들(handle)이란 구체적인 어떤 대상에 붙여진 번호이며 문법적으로는 32비트(또는 64비트)의 정수값이다.  
Windows에서는 여러 가지 종류의 핸들이 사용되고 있다.  
만들어진 윈도우에는 윈도우 핸들(hWnd)을 붙여 번호로 관리하며 아직은 잘 모르겠지만 DC에 대해서도 핸들을 사용하고 논리적 펜, 브러시에도 핸들을 붙여 관리한다.  
  
심지어 메모리를 할당할 때도 할당한 메모리의 번지를 취급하기보다는 메모리에 번호를 붙인 메모리 핸들을 사용하기도 했었다.  
왜 이렇게 핸들을 자주 사용하는가 하면 대상끼리의 구분을 위해서는 문자열보다 정수를 사용하는 것이 속도가 훨씬 더 빠르고 간편하기 때문이다.  
Windows에서 핸들을 이렇게 많이 사용하므로 우리는 핸들의 특성에 관해서 미리 숙지하는 것이 좋다. 핸들은 일반적으로 다음의 특징이 있다.  
  
1. 핸들은 일단 정수값이며 대부분의 경우 32비트값이다. 핸들을 사용하는 목적은 오로지 구분을 위한 것이므로 핸들끼리 중복되지 않아야 하며 이런 목적으로는 정수형이 가장 적합하다.   
정수형은 비교나 대입 연산이 가장 빠른 타입이므로 핸들로 쓰기에 적합하다.

2. 핸들은 운영체제가 발급하며 사용자는 쓰기만 한다.  
예를 들어 윈도우를 만들거나 파일을 열면 운영체제는 만들어진 윈도우나 파일에 핸들을 붙이고 그 값을 리턴한다.  
사용자는 이 핸들을 잘 보관해 두었다가 해당 윈도우나 파일을 다시 참조할 때 사용한다. 사용자가 직접 핸들을 만드는 경우는 없다.

3. 같은 종류의 핸들끼리는 절대로 중복된 값을 가지지 않는다.  
만약 이렇게 된다면 대상을 구분하는 본래의 목적을 달성할 수 없을 것이다.  
물론 다른 종류의 핸들끼리는 중복된 값을 갖리 수도 있다.

4. 핸들은 정수형이므로 값을 가지겠지만 그 실제값이 무엇인지는 몰라도 상관없다.  
핸들은 크고 작음의 성질을 가지는 숫자가 아니라 단순한 표식일 뿐이다.  
핸들형 변수를 만들어 핸들을 대입받아 쓰고 난 후에는 버리면 된다.  
마치 malloc한 포인터의 실제 위치가 어디인가 신경쓸 필요없이 사용하다가 free로 해제하면 그만인 것과 같다.

Windows에서 핸들을 예외없이 접두어 H로 시작되며 핸들값을 저장하기 위해 별도의 데이터형까지 정의해 두고 있다.  
HWND, HPEN, HBRUSH, HDC 등이 핸들을 담기 위한 데이터형들이며 모든 부호없는 정수형이다.

## 비트 OR 연산자

사용자는 원하는 작업을 하기 위해 함수를 호출한다.  
이때 함수에게 작업의 내용을 전달하는 인수가 같이 건네지는데 인수에는 작업의 목적과 방법을 저장하는 정보가 포함된다.  
예를 들어 printf("result is %d", num); 이라는 함수 호출문에서 출력할 문자열의 서식과 서식의 해석 방법을 두 개의 인수로 전달했으며 printf 함수는 이 인수값을 참조하여 사용자가 원하는 결과를 출력한다.  
  
Windows API 함수들도 마찬가지로 작업에 대한 세부 정보(옵션)를 인수로 전달받는다.  
그런데 전달 가능한 옵션이 여러 개 있을 경우 필요한 옵션수만큼 인수를 전달받는 것이 아니라 하나의 인수에 복수 개의 옵션을 묶어 전달하는데 이 때 사용된 연산자가 비트 OR연산자(|)이다.  
  
Windows에서는 이런 방식으로 옵션을 전달하는 경우가 빈번하다.  
CreateWindow 함수는 만들고자 하는 윈도우의 스타일을 인수로 전달받는데 WS_CHILD, WS_CAPTION, WS_BORDER 등 옵션이 수십 개나 되지만 단 하나의 인수로 이 옵션들을 모두 전달받는다.  
만약 각각의 스타일을 갭려 인수로 전달받는다면 이 함수는 엄청난 수의 인수를 가져야 할 것이다.  
  
뿐만 아니라 호출할 때는 CreateWindow(NULL, 0, FALSE, 0, 0, 0, ...)처럼 관심없는 인수에도 일일이 값을 지정해야 하므로 불편하고 스타일의 순서를 정확하게 외우는 것도 보통 일이 아니다.  
비트 OR 연산자를 사용하면 관심없는 인수는 생략해 버릴 수 있고 OR 연산은 교환 법칙이 성립하므로 값의 순서에 무관하며 여러 가지 옵션을 묶어서 전달하므로 호출 속도도 빠르다.  
DrawText 함수는 문자열 출력 방법을 하나의 인수로 전달받는데 역시 옵션의 수가 무척 많다.  
  
Winuser.h 헤더 파일을 보면 이 함수의 옵션 목록을 살펴볼 수 있다.  
  
- #define DT_TOP 0x00000000
- #define DT_LEFT 0x00000000
- #define DT_CENTER 0x00000001
- #define DT_RIGHT 0x00000002
- #define DT_VCENTER 0x00000004
- #define DT_BOTTOM 0x00000008
- #define DT_WORDBREAK 0x00000010
- #define DT_SINGLELINE 0x00000020
- #define DT_EXPANDTABS 0x00000040
- #define DT_TABSTOP 0x00000080
- #define DT_NOCLIP 0x00000100
- #define DT_EXTERNALLEADING 0x00000200
- #define DT_CALCRECT 0x0000400
- #define DT_NOPREFIX 0x00000800
- #define DT_INTERNAL 0x00001000
  
수평 정렬을 하는 옵션, 수직 정렬을 하는 옵션, 개행 여부 여러 줄 출력 등의 옵션들이 있는데 이 많은 옵션들이 OR 연산자로 연결되어 딱 하나의 인수로 전달된다.  
예를 들어 DT_CENTER | DT_BOTTOM | DT_WORDBREAK 등과 같이 하면 세 가지 옵션을 하나의 인수로 전달한 것이다.  
한 인수에 이렇게 여러 가지 옵션을 같이 전달할 수 있는 이유는 각 옵션이 비트별로 배정되어 있어 상호 간섭하지 않기 때문이다.  
옵션들의 실제값을 보면 1, 2, 4, 8 등과 같이 2의 거듭승으로 정의되어 옵션별로 비트 자리가 정해져 있다.  
  
그래서 여러 개의 옵션을 비트 OR 연산자로 묶어 하나의 정수값만 전달하더라도 함수는 인수의 개별 비트를 테스트한 후 어떠한 옵션이 선택되었는지를 알 수 있다.  
각 옵션의 실제 값이 어떻게 정의되어 있는가를 알 필요가 없으며 매크로 상수만 알면 되는데 매크로 상수가 곧 옵션의 이름이다.  
비트 OR 연산자를 잘 알고 있는 사람들에게는 너무 당연하게 생각되겠지만 이런 형태의 함수 인수 전달을 처음 보는 사람들에게는 무척 이상하게 보일 것이다.  
Widnows API 함수는 이런 식의 인수 전달법을 흔히 사용하며 때로는 별 상관없는 옵션들이 하나의 인수에 전달되는 경우도 있고 옵션끼리 상호 배타적인 경우도 있다.