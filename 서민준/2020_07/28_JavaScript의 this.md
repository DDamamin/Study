## JavaScript의 this

### 상황에 따라 달라지는 this

자바스크립트에서 this는 기본적으로 <u>실행 컨텍스트</u>가 생성될 때 함께 결정된다.

---

##### [ 참고 ] 실행 컨텍스트(execution context)란?

**실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**이라고 정의한다. 좀 더 쉽게 말하자면 **실행 가능한 코드가 실행되기 위해 필요한 환경**이라고 말할 수 있다. 여기서 말하는 실행 가능한 코드는 아래와 같다.

- 전역 코드 : 전역 영역에 존재하는 코드
- Eval 코드 : eval 함수로 실행되는 코드
- 함수 코드 : 함수 내에 존재하는 코드

자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러 정보를 가지고 있어야 한다.

- 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티
- 함수 선언
- 변수의 유효범위 (Scope)
- this

이 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다.

```javascript
var a = 'a';

function foo() {
    var f = 'foo';
    
    function bar() {
        var b = 'bar';
    }
    bar();
}
foo();
```

위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택이 생성되고 소멸된다. 현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드(Ex : 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다.

![실행 context](https://user-images.githubusercontent.com/51042546/88511434-c243ac80-d01f-11ea-9cab-4494de58d4fe.png)

1. 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 
2. 전역 코드(Golbal code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(Ex : 웹 페이지에서 나가기, 브라우저를 닫기)까지 유지된다.
3. 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.
4. 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.

[출처] : <a href="https://poiemaweb.com/js-execution-context" target="_blank">실행 컨텍스트와 자바스크립트의 동작 원리 - poiemaweb</a>

---

실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 **this는 함수 호출할 때 결정된다**고 할 수 있다. 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.

#### 전역 공간에서의 this

전역 공간에서 this는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다. 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다. 브라우저 환경에서 전역객체는 window이고 Node.js 환경에서는 global이다.

![전역 공간에서의 this_브라우저 환경](https://user-images.githubusercontent.com/51042546/88511964-ba383c80-d020-11ea-9776-836ad8f0ec5a.png)

전역변수를 선언하면 JavaScript 엔진은 이를 전역객체의 <u>프로퍼티</u>로도 할당합니다. 즉, 변수이면서 객체의 프로퍼티이기도 한 셈이다.

---

##### [ 참고 ] 프로퍼티 (property)란?

property는 **해당 object의 특징(속성)**이다. property는 보통 데이터 구조와 연관된 속성을 나타낸다. 2가지 종류가 있다.

- 인스턴스 property들은 특정 object 인스턴스의 특정한 데이터를 가지고 있다.
- Static Property들은 모든 object 인스턴스들에게 공유된 데이터를 가지고 있다.

property는 **이름(키)과 값(primitive, method or object reference)의 형식으로 구성**된다. 보통 "property가 object를 가지고 있다"고 말하는 것은 "property가 object reference"를 가지고 있다는 것을 줄여서 말한 것이다. property가 함수를 지니게 되면 method가 된다. property의 값이 변한 후에도 object는 그대로 남아있다.

[출처] : <a href="https://m.blog.naver.com/magnking/220966405605" target="_blank">[JavaScript] property란 무엇인가? - 쉽게 읽는 프로그래밍</a>

---

![전역변수와 전역객체 1](https://user-images.githubusercontent.com/51042546/88513322-0b493000-d023-11ea-83d3-4fcb42d8d3ac.png)

전역공간에서 선언한 변수 a에 할당했을 뿐인데 `window.a`와 `this.a` 모두 1이 출력된다. 전역공간에서의 this는 전역객체를 의미하므로 두 값이 같은 값을 출력하는 것은 당연하지만, 그 값이 1인 것은 조금 의아하다. 그 이유는 **자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티**로서 동작하기 때문이다. 사용자가 var 연산자를 이용해 변수를 선언하더라도 실제 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식하는 것이다. 특정 객체란 바로 실행 컨텍스트의 `LexicalEnvironment`이다. 실행 컨텍스트는 변수를 수집해서 `LexicalEnvironment`의 프로퍼티로 저장한다. 이후 어떤 변수를 호출하면 `LexicalEnvironment`를 조회해서 일치하는 프로퍼티가 있을 경우 그 값을 반환한다. 전역 컨텍스트의 경우 `GlobalEnv`가 전역 객체를 참조하는데 전역 컨텍스트의 `LexicalEnvironment`가 `GlobalEnv`를 참조한다.


> 전역변수를 선언하면 JavaScript 엔진은 이를 전역객체의 프로퍼티로도 할당합니다.

이 문장을 정확히 표현하면 **전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다**라고 표현하는 것이 옳다.

![전역변수와 전역객체 1](https://user-images.githubusercontent.com/51042546/88513322-0b493000-d023-11ea-83d3-4fcb42d8d3ac.png)

그럼 위 코드의 실행결과가 왜 이렇게 나오는지 이해할 수 있다. 변수 a에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 `LexicalEnvironment`, 즉 전역 객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환하기 때문이다.

---

##### [ 참고 ] 스코프 체인(scope chain)이란?

자바스크립트에도 유효 범위라는 것이 있다. 다만, for나 if와 같은 구문은 유효 범위가 없고, **오로지 함수만이 유효 범위의 한 단위가 된다.**

**유효 범위를 나타내는 스코프가 [[scope]] 프로퍼티로 각 함수 객체 내에서 연결리스트 형식으로 관리**되는데 이를 **스코프 체인**이라 한다.

각각의 함수는 [[scope]] 프로퍼티로 자신이 생성된 실행 컨텍스트의 스코프 체인을 참조한다. 함수가 실행되는 순간 실행 컨텍스트가 만들어지고, 이 실행 컨텍스트는 실행된 함수의 [[scope]] 프로퍼티를 기반으로 새로운 스코프 체인을 만든다.

[출처] : <a href="https://programmer-seva.tistory.com/36" target="_blank">[스터디_자바스크립트] 23. 스코픠 체인 - 세바의 코딩교실</a>

---

따라서 var로 변수를 선언하는 대신 `window`의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 동작할 것이라는 예상을 할 수 있다. 대부분의 경우에는 이 말이 맞다.

![전역변수와 전역객체 2](https://user-images.githubusercontent.com/51042546/88516215-e3100000-d027-11ea-85e8-b6284ad920c7.png)

그런데 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우가 바로 '삭제' 명령이다.

![전역변수와 전역객체 3](https://user-images.githubusercontent.com/51042546/88544647-aeff0400-d054-11ea-99fc-a3ca18a5dd9b.png)

변수에 delete 연산자를 쓰는 것이 이상해보일 수도 있는데, 해당 변수는 window(전역객체)의 프로퍼티로 할당되기 때문에 delete 연산자를 사용할 수 있다.

처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는 것을 확인할 수 있다. 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이라고 해석됩니다. 즉 전역변수를 선언하면 자바스크립트의 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 `configurable`속성(변경 및 삭제 가능성)을 false로 정의하는 것입니다.

---

##### [ 참고 ] configurable 자동 false 설정에 관하여

실제로 브라우저에서 작성한 결과 `configurable` 속성에 정의되지 않는 경우도 많이 있습니다. 이런 경우 위 예제를 실행하게 되면 `delete window.b;` 명령도 false로 인식되는데, 이때는 해당 프로퍼티에 `configurable` 속성을 false로 직접 지정해주면 더 이상 delete 연산자에 의해 삭제되지 않습니다.

---

이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 `configurable` 여부에서 차이를 보입니다.

#### 메서드로서 호출할 때 그 메서드 내부에서의 this

##### 함수 vs 메서드

어떤 함수를 실행하는 방법 중 가장 일반적인 방법 두 가지로는 함수로서 호출하는 경우와 메서드로서 호출하는 경우가 있다. 프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.

자바스크립트를 처음 접하는 경우 흔히 메서드를 '객체의 프로퍼티에 할당된 함수'로 이해하곤 한다. 반은 맞고 반은 틀린 말이다. 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.

![함수로서 호출, 메서드로서 호출](https://user-images.githubusercontent.com/51042546/88545614-2c774400-d056-11ea-8416-5f80c940b970.png)

첫 줄의 익명함수를 변수 func에 담아 실행했을 때는 this의 출력 결과로 window(전역객체)가 출력되었지만, obj라는 객체에 method라는 프로퍼티의 값으로 func를 할당한 뒤, method를 호출했을 때는 this의 출력결과로 obj가 출력된다. obj의 method 프로퍼티에 할당한 값과 func 변수에 할당한 값은 모두 첫 줄에서 선언한 함수를 참조한다. 즉 원래 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지게 된다.

함수로서 호출과 메서드로서의 호출은 함수 앞의 점(.)이 있는지 여부만으로 간단하게 구분할 수 있다. 물론 대괄호 표기법에 따른 경우에도 메서드로서 호출한 것입니다.

---

##### [ 참고 ] 대괄호 표기법이란?

객체 프로퍼티에 접근할 수 있는 방법 중 하나로 주로 for in과 함께 사용됩니다.

![메서드로서 호출 - 점 표기법, 대괄호 표기법](https://user-images.githubusercontent.com/51042546/88546490-67c64280-d057-11ea-9c78-d70c8e4312dc.png)

접근하려는 프로퍼티가 표현식이거나 예약어일 경우 반드시 대괄호 표기법만을 사용해 프로퍼티에 접근해야 한다.

[출처] : <a href="https://feel5ny.github.io/2018/08/23/JS_14/" target="_blank">3/ 자바스크립트 데이터 타입과 연산자 - 필오의 개발일지</a>

---

다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 경우에는 함수로 호출한 것입니다.

##### 메서드 내부에서의 this

this에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체입니다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 된다.

![method 내부에서의 this](https://user-images.githubusercontent.com/51042546/88548405-0489df80-d05a-11ea-954a-29e6cbad0ded.png)

#### 함수로서 호출할 때 그 함수 내부에서의 this

##### 함수 내부에서의 this

어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다. this에는 호출한 주체에 대한 정보가 담긴다고 했다. 그런데 함수로서 호출하는 것은 호출 주체(객체지향언어에서의 객체)를 명시하지 않고 개발자가 코드에 관여해 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다. 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다고 했다. 따라서 함수에서의 this는 전역 객체를 가리킨다. 그러나 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적한다.

---

##### [ 참고 ] 더글라스 크락포드

- 자바스크립트 언어의 개발에 참여한 미국의 컴퓨터 프로그래머이자 기업가

- JSON 데이터 포맷을 보급함
- JSLint, JSMin 등 다양한 자바스크립트 관련 도구들 개발

[출처] : <a href="[https://ko.wikipedia.org/wiki/%EB%8D%94%EA%B8%80%EB%9D%BC%EC%8A%A4_%ED%81%AC%EB%A1%9D%ED%8F%AC%EB%93%9C](https://ko.wikipedia.org/wiki/더글라스_크록포드)" target="_blank">더글라스 크록포드 - 위키백과</a>

---

