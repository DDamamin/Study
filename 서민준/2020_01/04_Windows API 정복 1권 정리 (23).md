# Windows API 정복 1권(김상형 저) 정리 23편

**저작권 문제시 연락주시면 바로 처리하도록 하겠습니다. 학생으로서 독서를 읽은 뒤 정리하면서 학습하는 용도로만 사용하였습니다. 양해 부탁드립니다.**

## SendMessage

타이머를 처음 만들어보면 실행한 직후 시간이 보이지 않다가 1초 정도 경과한 후부터 시간이 보이는 문제점이 있을 수 있다. 화면 출력을 담당하는 WM_PAINT에서는 무조건 sTime 문자열을 출력하기만 하고 이 문자열은 WM_TIMER에서 시간값을 조사한 후 설정하므로 WM_PAINT는 죄가 없다. 문제는 시간을 조사하는 WM_TIMER 메시지가 최초로 호출되는 시점이 프로그램 시작 1초 후라는 점이다. 왜 그런가 하면 WM_CREATE에서 타이머를 설치할 때 타이머 주기를 1초로 지정했기 때문이다. 이 문제를 해결하려면 프로그램 시작 직후에 WM_TIMER 메시지를 강제로 발생시켜 시간을 먼저 조사해야 한다. 이 때 사용되는 함수가 SendMessage이다.  
  
    LRESULT SendMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

메시지는 사용자의 동작이나 시스템의 상황 변화에 의해 발생하는 것이 원칙이지만 강제로 메시지가 발생한 것처럼 만들어야 할 때는 이 함수를 사용하여 hWnd 윈도우로 Msg 메시지를 보내면 된다. 그러면 hWnd는 Msg 메시지가 발생한 것으로 인식하고 필요한 처리를 하게 될 것이다.  
  
이 함수를 호출해야 할 시점은 프로그램이 시작된 직후인 WM_CREATE에서이다.  
  
    case WM_CREATE:
        SetTimer(hWnd, 1, 1000, NULL);
        SendMessage(hWnd, WM_TIMER, 1, 0);
        return 0;

타이머를 설치한 직후에 SendMessage로 WM_TIMER 메시지를 보내 곧바로 시간을 조사하도록 했다. sTime에 시간이 조사되었으므로 윈도우가 화면에 보이는 즉시 이 문자열이 나타날 것이다.  
  
SendMessage의 세 번째, 네 번째 인수는 메시지의 추가 정보인 wParam, lParam이며 보내는 메시지의 종류에 따라 의미는 달라진다. **WM_TIMER 메시지는 wParam으로 타이머 ID를 보내도록 되어 있으므로** SendMessage의 세 번째 인수에 타이머 ID인 1을 지정했다. **SendMessage의 리턴값은 메시지 처리 함수가 리턴하는 값이며 메시지에 따라 해석 방법이 다르다.**  
  
메시지 기반의 운영체제인 Widnows에서 SendMessage는 아주 빈번하게 사용되는 중요한 함수이다. 이 예제에서는 WM_TIMER 메시지를 강제로 보내기 위해 사용했는데 어떤 종류의 메시지라도 누구에게나 보낼 수 있으며 SendMessage의 이런 기능은 차일드 컨트롤을 프로그래밍하는 아주 중요한 수단으로 사용된다. 자주 사용할 함수이므로 눈여겨 봐 두자. 원형이 WndProc과 같아 외우기도 쉽다.  
  
시간이 바뀔 때마다 화면이 깜빡거린다는 점이다. 컴퓨터가 굉장히 빠르거나 화면이 작다면 잘 느낄 수 없지만 윈도우를 최대화해 놓고 보면 시간이 바뀔 때마다 글자들이 지워졌다가 다시 그려지는 것이 보일 것이다. 왜 그런가 하면 WM_TIMER 메시지에서 시간을 변경한 후 화면을 다시 그리기 위해 다음 함수를 호출하기 때문이다.  
  
    InvalidateRect(hWnd, NULL, TRUE);

hWnd 윈도우를 무효화하되 두 번째 인수가 NULL이므로 화면 전체가 무효화되며 세 번째 인수가 TRUE이므로 일단 화면을 지운 후 다시 그린다. 화면 전체를 몽땅 다 지운 후 다시 출력했기 때문에 깜박거리는 것이 눈에 보이는 것이다. 그렇다고 해서  세 번째 인수를 FALSE로 변경하여 지우지 않으면 이전에 출력되었던 시간 위에 갱신된 시간이 덮여서 출력되므로 그렇게 해서도 안 된다.  
  
세 번째 인수를 FALSE로 바꿔 놓고 테스트해 보아라. 대부분의 경우 이전 시간과 새로 조사된 시간의 길이가 같기 때문에 덮어 써도 아무 문제가 없지만 시간 문자열의 길이가 짧아질 경우 예를 들어 10 : 59 : 59에서 11 : 0 : 0이 될 때는 뒤쪽 문자열이 지워지지 않아 잔상이 남을 것이다. 그래서 원래 그려져 있던 내용을 지워야 하므로 세 번째 인수는 TRUE가 되어야 한다.  
  
이럴 경우 지우기는 하되 무효영역을 최소화하여 꼭 필요한 부분만 무효화하면 깜빡임을 많이 줄일 수 있다. 즉 다음과 같이 InvalidateRect 함수의 두 번째 인수에 무효화할 영역을 전달하여 이 부부만 무효화함으로써 최대한 빨리 윈도우를 다시 그리도록 하는 것이다.  
  
    static RECT rt = { 100, 100, 400, 120 };

    switch (iMessage)
    {
    ......
    case WM_TIMER:
        GetLocalTime(&st);
        wsprintf(sTime, TEXT("지금 시간은 %d : %d : %d 입니다."), st.wHour, st.wMinute, st.wSecond);
        InvalidateRect(hWnd, &rt, TRUE);
        return 0;
    }

문자열이 출력되는 영역인 (100, 100) - (400, 120) 사각영역을 정의한 후 이 영역만 무효화하였다. 그러면 WM_PAINT 메시지에서는 이 영역 외부는 지우지도 않고 그리지도 않으며 전혀 신경쓰지 않으므로 그리는 속도가 현저히 빨라진다. 그리는 속도가 빠르기 때문에 화면 깜빡임도 웬만해서는 눈에 보이지 않을 것이다.  
  
여기서 설정한 사각영역은 실습의 편의를 위해 대충 눈대중으로 설정하였는데 좀 더 완벽하게 하려면 문자열이 출력될 사각영역을 계산하여 더 좁은 영역을 무효화할 수도 있다. 이런 처리를 얼마나 깔끔하게 하느냐에 따라 프로그램의 질이 달라진다.